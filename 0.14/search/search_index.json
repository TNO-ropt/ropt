{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>ropt</code>: A Python module for robust optimization","text":"<p><code>ropt</code> is a module designed for implementing and executing robust optimization workflows. In classical optimization problems, a deterministic function is optimized. However, in robust optimization, the function is expected to exhibit a stochastic nature and is represented by an ensemble of functions (realizations) for different values of some (possibly unknown) random parameters. The optimal solution is then determined by optimizing the value of a statistic, such as the mean, over the ensemble.</p> <p><code>ropt</code> can be employed to construct optimization workflows directly in Python or as a building block in optimization applications. At a minimum, the user needs to provide additional code to calculate the values for each function realization in the ensemble. This can range from simply calling a Python function that returns the objective values to initiating a long-running simulation on an HPC cluster and reading the results. Furthermore, <code>ropt</code> exposes all intermediate results of the optimization, such as objective and gradient values, but functionality to report or store any of these values must be added by the user. Optional functionality to assist with this is included with <code>ropt</code>.</p> <p><code>ropt</code> provides several features for efficiently solving complex robust optimization problems:</p> <ul> <li>Robust optimization over an ensemble of models, i.e., optimizing the average   of a set of objective functions. Alternative objectives can be implemented   using plugins, for instance, to implement risk-aware optimization, such as   Conditional Value at Risk (CVaR) or standard-deviation-based functions.</li> <li>Support for black-box optimization of arbitrary functions.</li> <li>Support for running complex optimization workflows, such as multiple runs with   different optimization settings or even different optimization methods.</li> <li>Support for nested optimization, allowing sub-sets of the variables to be   optimized by optimization workflows that run as part of the black-box function   to be optimized.</li> <li>An interface for running various continuous and discrete optimization methods.   By default, optimizers from the   <code>scipy.optimize</code>   package are included, but additional optimizers can be added via a plugin   mechanism. The most common options of these optimizers can be configured in a   uniform manner, although algorithm- or package-specific options can still be   passed.</li> <li>Efficient estimation of gradients using a Stochastic Simplex Approximate   Gradient (StoSAG) approach. Additional samplers for generating perturbed   values for gradient estimation can be added via a plugin mechanism.</li> <li>Support for linear and non-linear constraints, if supported by the chosen   optimizer.</li> <li>Flexible configuration of the optimization process using   <code>pydantic</code>.</li> <li>Support for tracking and processing optimization results generated during the   optimization process.</li> <li>Support for generating formatted tables of the results.</li> <li>Optional support for exporting results as   <code>pandas</code> data frames.</li> </ul>"},{"location":"reference/default_function_estimator_plugin/","title":"Default Function Estimator Plugin","text":""},{"location":"reference/default_function_estimator_plugin/#ropt.plugins.function_estimator.default.DefaultFunctionEstimator","title":"<code>ropt.plugins.function_estimator.default.DefaultFunctionEstimator</code>","text":"<p>               Bases: <code>FunctionEstimator</code></p> <p>The default function estimator plugin.</p> <p>This plugin currently implements two methods:</p> <code>mean</code>: Calculate the combined functions as a weighted mean of the function    values of each realization. Gradients are accordingly calculated as    a weighted sum. <code>stddev</code>: Calculate the combined functions as the standard deviation of function    values of each realization. Gradients are calculated accordingly using    the chain rule. The sign of the result is adjusted such that the standard    deviation is always minimized."},{"location":"reference/default_plan_plugin/","title":"Default Plan Plugin","text":""},{"location":"reference/default_plan_plugin/#ropt.plugins.plan.default.DefaultPlanPlugin","title":"<code>ropt.plugins.plan.default.DefaultPlanPlugin</code>","text":"<p>               Bases: <code>PlanPlugin</code></p> <p>The default plan plugin class.</p> <p>This class provides a number of steps and result handlers:</p> <code>Steps</code>: <ul> <li>A step that modifies one or more variables (<code>set</code>).</li> </ul> <ul> <li>A step that loads data from a file (<code>load</code>).</li> </ul> <ul> <li>A step that saves data to a file (<code>save</code>).</li> </ul> <ul> <li>A step that performs a single ensemble evaluation (<code>evaluator</code>).</li> </ul> <ul> <li>A step that runs an optimization (<code>optimizer</code>).</li> </ul> <ul> <li>A step that prints a message to the console (<code>print</code>).</li> </ul> <ul> <li>A step that repeats a number of steps (<code>repeat</code>).</li> </ul> <code>Result Handlers</code>: <ul> <li>A handler that adds metadata to results (<code>metadata</code>).</li> </ul> <ul> <li>A handler that tracks optimal results (<code>tracker</code>).</li> </ul>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._set.DefaultSetStep","title":"<code>ropt.plugins.plan._set.DefaultSetStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default set step.</p> <p>Set steps are used to modify the contents of plan variables. They specify one or more variables to set, either as a dictionary of variable-name/value pairs, or as a list of such dictionaries.</p> <p>Variables containing dictionaries can be modified by specifying an entry using the <code>[]</code> operator. Similarly, variables containing objects with attributes can be modified using the <code>.</code> operator. These can be mixed and nested to any depth to modify complex variables. For example, the expression <code>$var['foo'].bar[0]</code> is valid if <code>var</code> contains a dict-like value with a <code>foo</code> entry that has a <code>bar</code> attribute containing a list.</p> <p>The evaluator step uses the <code>DefaultSetStepWith</code> configuration class to parse the <code>with</code> field of the <code>PlanStepConfig</code> used to specify this step in a plan configuration.</p> Dictionary vs Lists <p>Multiple variables may be set in a single step, either by using a single dictionary of variable/value pairs or by providing a list of dictionaries. Both approaches are generally equivalent. However, if a dictionary is loaded from a JSON or YAML file, the order of the keys is not guaranteed. Keep this in mind if the variables are interdependent and the assignment order matters.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._set.DefaultSetStep.DefaultSetStepWith","title":"<code>DefaultSetStepWith</code>","text":"<p>               Bases: <code>RootModel[dict[str, Any] | tuple[dict[str, Any], ...]]</code></p> <p>Configuration for a set step.</p> <p>A set step is used to change the value of one or more plan variables. The parameters provided to the step should either be a dictionary of variable-name/value pairs, or a list of such dictionaries. When the set step is run by the plan, the variables are set to the given values. Variables that are referenced may be dictionaries or objects with attributes. These can be modified by using the <code>[]</code> or <code>.</code> operators (possibly nested) with the specified variable name.</p> Using Expressions in the Value <p>Optionally, the supplied value may be an expression, following the rules of the <code>eval</code> method of the plan object executing the steps. Refer to the method's documentation for more information on supported expressions.</p> Dictionaries vs. Lists <p>The parameters provided to the set step may be dictionaries or lists of dictionaries. Multiple variables can be set in this manner in both cases. However, care should be taken if a dictionary is used where the order of the keys is not well defined, for instance, if it has been read from a JSON file. If the order in which variables are set is important, it is recommended to use a list.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._load_data.DefaultLoadStep","title":"<code>ropt.plugins.plan._load_data.DefaultLoadStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default load step.</p> <p>The load step loads data from a file and deserializes it into a variable.</p> <p>This step uses the <code>DefaultLoadStep</code> configuration class to parse the <code>with</code> field of the <code>PlanStepConfig</code>, which defines the settings for this step within a plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._load_data.DefaultLoadStep.DefaultLoadStepWith","title":"<code>DefaultLoadStepWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used by the load step.</p> <p>This configuration specifies the name of the variable to store the result and the file path for the file to load.</p> <p>The <code>format</code> option specifies the file format. Currently, the following formats are supported:</p> <ul> <li><code>json</code>:   Load the data from a JSON file.</li> <li><code>pickle</code>: Load the data from a pickle file.</li> </ul> <p>The <code>format</code> option is optional, if <code>None</code> or not provided (the default), the step will attempt to derive the data format from the extension of the input path.</p> <p>Attributes:</p> Name Type Description <code>var</code> <code>str</code> <p>Name of the variable to store the result.</p> <code>path</code> <code>str | Path</code> <p>File path to load.</p> <code>format</code> <code>Literal['json', 'pickle'] | None</code> <p>The format of the file.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._save.DefaultSaveStep","title":"<code>ropt.plugins.plan._save.DefaultSaveStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default save step.</p> <p>The save step saves data to a file using the specified format.</p> <p>This step uses the <code>DefaultSaveStepWith</code> configuration class to parse the <code>with</code> field of the <code>PlanStepConfig</code>. The configuration specifies the settings for this step in a plan setup.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._save.DefaultSaveStep.DefaultSaveStepWith","title":"<code>DefaultSaveStepWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration parameters for the save step.</p> <p>This configuration defines what data is saved by and specifies the file path for storing the output. If the path includes directories that do not yet exist, they will be created.</p> <p>The <code>format</code> option defines the file format for saving the data. Supported formats are:</p> <ul> <li><code>json</code>:   Saves the data in JSON format.</li> <li><code>pickle</code>: Saves the data in a pickle file.</li> </ul> <p>The <code>format</code> option is optional, if <code>None</code> or not provided (the default), the step will attempt to derive the data format from the extension of the output path.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Any</code> <p>The data to save.</p> <code>path</code> <code>str | Path</code> <p>The file path where the output will be stored.</p> <code>format</code> <code>Literal['json', 'pickle'] | None</code> <p>The format used for file storage, determining the serialization method.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan.evaluator.DefaultEvaluatorStep","title":"<code>ropt.plugins.plan.evaluator.DefaultEvaluatorStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default evaluator step.</p> <p>This step performs a single ensemble evaluation, yielding one or more <code>FunctionResults</code> objects. The evaluation can process multiple variable vectors, each of which is evaluated separately, producing an individual results object for each vector.</p> <p>Before executing the evaluator step, a <code>START_EVALUATOR_STEP</code> event is emitted. After the evaluator step finishes, an <code>FINISHED_EVALUATOR_STEP</code> event is emitted. Result handlers should respond to the latter event to process the generated results.</p> <p>The evaluator step uses the <code>DefaultEvaluatorStepWith</code> configuration class to parse the <code>with</code> field of the <code>PlanStepConfig</code> used to specify this step in a plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan.evaluator.DefaultEvaluatorStep.DefaultEvaluatorStepWith","title":"<code>DefaultEvaluatorStepWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used by the default evaluator step.</p> <p>The <code>DefaultEvaluatorStep</code> requires an optimizer configuration; the <code>tags</code> and <code>values</code> parameters are optional. The configuration  object must be an <code>EnOptConfig</code> object, or a dictionary that can be parsed into such an object. If no <code>values</code> are provided, the initial values specified by the optimizer configuration are used. If <code>values</code> is given, it may be a single vector or a two-dimensional array. In the latter case, each row of the matrix is treated as a separate set of values to be evaluated.</p> <p>The <code>tags</code> field allows optional labels to be attached to each result, which can assist result handlers in filtering relevant results.</p> <p>The <code>data</code> field can be used to pass additional information via the <code>data</code> field of the events emitted by the optimizer step. Avoid the use of <code>results</code> and <code>exit_code</code> in this field, as these are already passed in the event data.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>The optimizer configuration.</p> <code>tags</code> <code>ItemOrSet[str]</code> <p>Tags to add to the emitted events.</p> <code>values</code> <code>str | Array2D | None</code> <p>Values to evaluate at.</p> <code>data</code> <code>dict[str, Any]</code> <p>Data to pass via events.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan.optimizer.DefaultOptimizerStep","title":"<code>ropt.plugins.plan.optimizer.DefaultOptimizerStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default optimizer step.</p> <p>The optimizer step performs an optimization, yielding a sequence of <code>FunctionResults</code> and <code>GradientResults</code> objects. The optimizer is configured using an <code>EnOptConfig</code> object or a dictionary that can be parsed into such an object. While the initial values for optimization are typically specified in the configuration, they can be overridden by providing them directly.</p> <p>The optimizer step emits several signals:</p> <ul> <li><code>START_OPTIMIZER_STEP</code>:   Emitted before the optimization starts.</li> <li><code>FINISHED_OPTIMIZER_STEP</code>:   Emitted after the optimization finishes.</li> <li><code>START_EVALUATION</code>: Emitted   before a function or gradient evaluation.</li> <li><code>FINISHED_EVALUATION</code>: Emitted   after a function or gradient evaluation.</li> </ul> <p>The <code>FINISHED_EVALUATION</code> signal is particularly important as it passes   the generated <code>Results</code> objects. Result handlers   specified in the plan will respond to this signal to process those results.</p> <p>The optimizer step supports nested optimizations, where each function evaluation in the optimization triggers a nested optimization plan that should produce the result for the function evaluation.</p> <p>The optimizer step utilizes the <code>DefaultOptimizerStepWith</code> configuration class to parse the <code>with</code> field of the <code>PlanStepConfig</code> used to specify this step in a plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan.optimizer.DefaultOptimizerStep.DefaultOptimizerStepWith","title":"<code>DefaultOptimizerStepWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used by the default optimizer step.</p> <p>The <code>DefaultOptimizerStep</code> requires an optimizer configuration; all other parameters are optional. The configuration object must be an <code>EnOptConfig</code> object or a dictionary that can be parsed into such an object. Initial values can be provided optionally; if not specified, the initial values defined by the optimizer configuration will be used.</p> <p>The <code>exit_code_var</code> field can be used to specify the name of a plan variable where the <code>exit code</code> is stored, which the optimizer returns upon completion.</p> <p>The <code>tags</code> field allows optional labels to be attached to each result, assisting result handlers in filtering relevant results.</p> <p>The <code>data</code> field can be used to pass additional information via the <code>data</code> field of the events emitted by the optimizer step. Avoid the use of <code>results</code> and <code>exit_code</code> in this field, as these are already passed in the event data.</p> <p>The <code>nested_optimization_plan</code> is parsed as a <code>NestedPlanConfig</code> to define an optional nested optimization procedure.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>The optimizer configuration.</p> <code>tags</code> <code>ItemOrSet[str]</code> <p>Tags to add to the emitted events.</p> <code>initial_values</code> <code>str | Array1D | None</code> <p>The initial values for the optimizer.</p> <code>exit_code_var</code> <code>str | None</code> <p>Name of the variable to store the exit code.</p> <code>data</code> <code>dict[str, Any]</code> <p>Data to pass via events.</p> <code>nested_optimization</code> <code>NestedPlanConfig | None</code> <p>Optional nested optimization plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan.optimizer.DefaultOptimizerStep.NestedPlanConfig","title":"<code>NestedPlanConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters needed by a nested plan.</p> <p>A nested plan will be executed by its parent plan each time it evaluates a function. While a nested plan is a standard <code>Plan</code>, it must adhere to certain rules:</p> <ul> <li>It must accept at least one input variable that holds the variable   values at which the parent plan intends to evaluate a function.</li> <li>It must return one result, which the parent plan will accept as the   result of the function evaluation.</li> </ul> <p>Extra inputs to the nested plan can be specified using the <code>extra_inputs</code> field. The nested plan must account for these extra inputs accordingly.</p> <p>Nested plans run independently, similar to a standard plan. They typically produce <code>Results</code>, which may be processed using result handlers defined in the nested plan. Once these handlers have executed, the results are also 'bubbled' up to the parent plan, where they are processed with its own handlers.</p> <p>Attributes:</p> Name Type Description <code>plan</code> <code>PlanConfig</code> <p>The nested plan.</p> <code>extra_inputs</code> <code>ItemOrTuple[Any]</code> <p>Extra inputs passed to the plan.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._print.DefaultPrintStep","title":"<code>ropt.plugins.plan._print.DefaultPrintStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default print step.</p> <p>The print step is used to display messages on the console, using Python's <code>print</code> function. The message to be printed must be a string evaluated by the <code>eval</code> method of the executing <code>Plan</code> object. The message should be enclosed in <code>[[...]]</code> delimiters; if these delimiters are missing, they are implicitly added around the message. This format allows for optional interpolation of embedded expressions, delimited by <code>${ ... $}</code>.</p> <p>The print step uses the <code>DefaultPrintStepWith</code> configuration class to parse the <code>with</code> field of the <code>PlanStepConfig</code> used to specify this step in a plan configuration.</p> Shorthand configuration <p>With this step it is possible to configure the message in shorthand notation. Instead of</p> <pre><code>{\n    \"run\": \"print\",\n    \"with\": {\n        \"message\": \"Hello World!\",\n    }\n}\n</code></pre> <p>or</p> <pre><code>{\n    \"print\": {\n        \"message\": \"Hello World!\",\n    }\n}\n</code></pre> <p>You can use:</p> <pre><code>{\n    \"print\":  \"Hello World!\",\n}\n</code></pre>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._print.DefaultPrintStep.DefaultPrintStepWith","title":"<code>DefaultPrintStepWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used by the print step.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The message to print.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._repeat.DefaultRepeatStep","title":"<code>ropt.plugins.plan._repeat.DefaultRepeatStep</code>","text":"<p>               Bases: <code>PlanStep</code></p> <p>The default repeat step.</p> <p>This step executes a defined list of steps in sequence for a specified number of repetitions. Optionally, it can store the current iteration number in a variable for tracking purposes. Each iteration preserves the original order of steps, ensuring sequential execution rather than parallel.</p> <p>The repeat step uses the <code>DefaultRepeatStepWith</code> configuration class to interpret the <code>with</code> field of the <code>PlanStepConfig</code> in a plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._repeat.DefaultRepeatStep.DefaultRepeatStepWith","title":"<code>DefaultRepeatStepWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used by the default repeat step.</p> <p>The <code>steps</code> parameter defines a sequence of actions that are executed repeatedly, with the number of repetitions determined by <code>iterations</code>. If <code>var</code> is specified, it will be set to the current iteration count before each round of steps, allowing for iteration-specific actions or tracking.</p> <p>Attributes:</p> Name Type Description <code>iterations</code> <code>int</code> <p>The number of repetitions to perform.</p> <code>steps</code> <code>list[PlanStepConfig]</code> <p>The list of steps to repeat in each iteration.</p> <code>var</code> <code>str | None</code> <p>Optional variable to update with the current iteration count.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._metadata.DefaultMetadataHandler","title":"<code>ropt.plugins.plan._metadata.DefaultMetadataHandler</code>","text":"<p>               Bases: <code>ResultHandler</code></p> <p>The default metadata results handler.</p> <p>This handler adds arbitrary metadata to results produced by steps by merging them into the <code>metadata</code> field of the <code>Results</code> objects that it receives. It is configured using a dictionary that maps keys to the data to store. These data entries can be of any type; however, if they are strings, they will be evaluated using the <code>eval</code> method of the executing <code>Plan</code> object. This evaluation occurs when the metadata handler processes an event, enabling dynamic data insertion based on the current content of plan variables.</p> <p>The metadata step uses the <code>DefaultMetadataHandlerWith</code> configuration class to parse the <code>with</code> field of the <code>ResultHandler</code> used to specify this handler in a plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._metadata.DefaultMetadataHandler.DefaultMetadataHandlerWith","title":"<code>DefaultMetadataHandlerWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters used by the default metadata results handler.</p> <p>The data to merge into the metadata of a result are required.</p> <p>The <code>tags</code> field allows optional labels to be attached to each result, which can assist result handlers in filtering relevant results.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict[str, Any]</code> <p>Data to merge into the metadata of the results.</p> <code>tags</code> <code>ItemOrSet[str]</code> <p>Optional tags specifying which result sources to modify.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._tracker.DefaultTrackerHandler","title":"<code>ropt.plugins.plan._tracker.DefaultTrackerHandler</code>","text":"<p>               Bases: <code>ResultHandler</code></p> <p>The default tracker results handler object.</p> <p>This handler tracks the <code>Results</code> objects that it receives and selects one to retain in a variable. Currently it tracks either the last result it receives, or the best result. The best result is defined as the result that has the lowest weighted objective value. Optionally, results may be filtered by checking for violations of constraints, by comparing constraint values to a threshold.</p> <p>The tracker step uses the <code>DefaultTrackerHandlerWith</code> configuration class to parse the <code>with</code> field of the <code>ResultHandler</code> used to specify this handler in a plan configuration.</p>"},{"location":"reference/default_plan_plugin/#ropt.plugins.plan._tracker.DefaultTrackerHandler.DefaultTrackerHandlerWith","title":"<code>DefaultTrackerHandlerWith</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters for the tracker results handler.</p> <p>The tracker stores the tracked results in the variable specified by the <code>var</code> field. The <code>type</code> parameter determines which result is tracked:</p> <ul> <li><code>\"best\"</code>: Tracks the best result added.</li> <li><code>\"last\"</code>: Tracks the last result added.</li> <li><code>\"all\"</code>:  Store a tuple with all results.</li> </ul> <p>If <code>constraint_tolerance</code> is set, results that exceed this tolerance on constraint values are not tracked.</p> <p>The <code>tags</code> field allows optional labels to be attached to each result, assisting result handlers in filtering relevant results.</p> <p>Attributes:</p> Name Type Description <code>var</code> <code>str</code> <p>The name of the variable to store the tracked result.</p> <code>tags</code> <code>ItemOrSet[str]</code> <p>Tags to filter the sources to track.</p> <code>type</code> <code>ItemOrSet[str]</code> <p>Specifies the type of result to store.</p> <code>constraint_tolerance</code> <code>float | None</code> <p>An optional constraint tolerance level.</p>"},{"location":"reference/default_realization_filter_plugin/","title":"Default Realization Filter Plugin","text":""},{"location":"reference/default_realization_filter_plugin/#ropt.plugins.realization_filter.default.DefaultRealizationFilter","title":"<code>ropt.plugins.realization_filter.default.DefaultRealizationFilter</code>","text":"<p>               Bases: <code>RealizationFilter</code></p> <p>The default realization filter plugin class.</p> <p>This plugin currently implements four methods:</p> <code>sort-objective</code>: Filter realizations by selecting a range of objective values. This filter    requires additional configuration using an options dict that can be    parsed into a    <code>SortObjectiveOptions</code>    class. This method sorts realizations according to the weighted sum of    the values of objective functions specified in the options. It then    selects the set of realizations from a given index range. <code>sort-constraint</code>: Filter realizations by selecting a range of constraint values. This    filter requires additional configuration using an options dict that can    be parsed into a    <code>SortConstraintOptions</code>    class. This method sorts realizations according to the values of    constraint functions specified in the options. It then selects the set of    realizations from a given index range. <code>cvar-objective</code>: Filter realizations by selecting a range of objective values. This filter    requires additional configuration using an options dict that can be    parsed into a    <code>CVaRObjectiveOptions</code>    class. This method sorts realizations according to the weighted sum of    the values of objective functions specified in the options. It then    selects a percentile of the realizations, applying interpolation whenever    the number of selected realizations is not an integer number. <code>cvar-constraint</code>: Filter realizations by selecting a range of constraint values. This    filter requires additional configuration using an options dict that can    be parsed into a    <code>CVaRConstraintOptions</code>    class. This method sorts realizations according to the values of    constraint functions specified in the options. It then selects a    percentile of the realizations, applying interpolation whenever the    number of selected realizations is not an integer number."},{"location":"reference/default_realization_filter_plugin/#ropt.plugins.realization_filter.default.SortObjectiveOptions","title":"<code>ropt.plugins.realization_filter.default.SortObjectiveOptions</code>","text":"<p>               Bases: <code>_ConfigBaseModel</code></p> <p>Configuration settings for the <code>sort-objective</code> method.</p> <p>The <code>sort-objective</code> method sorts realizations according to the value of one or multiple objectives, and retains a number of realizations within a given index range in the sorted list. If more than one objective index is given, a weighted sum of these objectives is used, using the weights given in the configuration of the optimizer.</p> <p>Attributes:</p> Name Type Description <code>sort</code> <code>list[NonNegativeInt]</code> <p>The indices of the objectives to sort.</p> <code>first</code> <code>NonNegativeInt</code> <p>Index or name of the first realization to use.</p> <code>last</code> <code>NonNegativeInt</code> <p>Index of name of the last realization to use.</p>"},{"location":"reference/default_realization_filter_plugin/#ropt.plugins.realization_filter.default.SortConstraintOptions","title":"<code>ropt.plugins.realization_filter.default.SortConstraintOptions</code>","text":"<p>               Bases: <code>_ConfigBaseModel</code></p> <p>Configuration settings for the <code>sort-constraint</code> method.</p> <p>The <code>sort-constraint</code> method sorts realizations according to the value of a constraint, and retains a number of realizations within a given index range in the sorted list.</p> <p>Attributes:</p> Name Type Description <code>sort</code> <code>NonNegativeInt</code> <p>The index of the constraint to sort.</p> <code>first</code> <code>NonNegativeInt</code> <p>Index or name of the first realization to use.</p> <code>last</code> <code>NonNegativeInt</code> <p>Index or name of the last realization to use.</p>"},{"location":"reference/default_realization_filter_plugin/#ropt.plugins.realization_filter.default.CVaRObjectiveOptions","title":"<code>ropt.plugins.realization_filter.default.CVaRObjectiveOptions</code>","text":"<p>               Bases: <code>_ConfigBaseModel</code></p> <p>Configuration settings for the <code>cvar-objective</code> method.</p> <p>The <code>cvar-objective</code> method finds realizations weights by applying the CVaR method to the objective values. If more than one objective index is given, a weighted sum of these objectives is used, using the weights given in the configuration of the optimizer.</p> <p>The percentile argument defines the contribution of the \"worst\" performing realizations in the distribution that is used to calculate the ensemble value. \"Worst\" is defined as those realizations having the highest values in case of a minimization and those having the lowest values in case of maximizing.</p> <p>Attributes:</p> Name Type Description <code>sort</code> <code>list[NonNegativeInt]</code> <p>The indices of the objectives to sort.</p> <code>percentile</code> <code>Annotated[float, Field(gt=0.0, le=1.0)]</code> <p>The CVaR percentile.</p>"},{"location":"reference/default_realization_filter_plugin/#ropt.plugins.realization_filter.default.CVaRConstraintOptions","title":"<code>ropt.plugins.realization_filter.default.CVaRConstraintOptions</code>","text":"<p>               Bases: <code>_ConfigBaseModel</code></p> <p>Configuration settings for the <code>cvar-constraint</code> method.</p> <p>The <code>cvar-constraint</code> method finds realizations weights by applying the CVaR method to the objective values.</p> <p>The percentile argument defines the contribution of the \"worst\" performing realizations in the distribution that is used to calculate the ensemble value. The definition of worst depends on the type of the constraints. After subtracting the right-hand-side value the following applies:</p> <ul> <li>For LE constraints, realizations with the largest values are the worst</li> <li>For GE constraints, realizations with the smallest values are the worst</li> <li>For EQ constraints, realizations with the largest absolute values are the worst</li> </ul> <p>Attributes:</p> Name Type Description <code>sort</code> <code>NonNegativeInt</code> <p>The index of the constraint to sort.</p> <code>percentile</code> <code>Annotated[float, Field(gt=0.0, le=1.0)]</code> <p>The CVaR percentile.</p>"},{"location":"reference/enopt_config/","title":"Optimizer Configuration","text":""},{"location":"reference/enopt_config/#ropt.config.enopt","title":"<code>ropt.config.enopt</code>","text":"<p>The <code>ropt.config.enopt</code> module contains optimization configuration classes.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.EnOptConfig","title":"<code>EnOptConfig</code>","text":"<p>The primary configuration class for a single optimization step.</p> <p>The fields of the <code>EnOptConfig</code> class are nested configuration classes that specify specific aspects of a single optimization run.</p> <p>The <code>realization_filters</code>, <code>function_estimators</code>, and <code>samplers</code> fields are defined as tuples of configurations for realization filter, function estimator, and sampler objects, respectively. Other configuration fields will refer to these objects by their index into these tuples. For example, the <code>gradient</code> field is implemented by the <code>GradientConfig</code> class, which contains a <code>samplers</code> field that is an array of indices, indicating for each variable which sampler should be used.</p> <p>The original values of all fields used to create the object will be stored internally and are available via the <code>original_inputs</code> field.</p> Info <p>Many of these nested classes contain fields that are <code>numpy</code> arrays of values. In general, these arrays must have a given size defined by the configured property or a size of one. For instance, the <code>variables</code> field must be an object of the <code>VariablesConfig</code> class, which contains information about the variables to be optimized. This includes such properties as initial values, bounds, and so on, which are defined as <code>numpy</code> arrays. The size of these arrays must be either equal to the number of variables or equal to one, in which case that single value is used for all variables.</p> <p>Attributes:</p> Name Type Description <code>variables</code> <code>VariablesConfig</code> <p>Configuration of the variables.</p> <code>objectives</code> <code>ObjectiveFunctionsConfig</code> <p>Configuration of the objective functions.</p> <code>linear_constraints</code> <code>LinearConstraintsConfig | None</code> <p>Configuration of linear constraints.</p> <code>nonlinear_constraints</code> <code>NonlinearConstraintsConfig | None</code> <p>Configuration of non-linear constraints.</p> <code>realizations</code> <code>RealizationsConfig</code> <p>Configuration of the realizations.</p> <code>optimizer</code> <code>OptimizerConfig</code> <p>Configuration of the optimizer.</p> <code>gradient</code> <code>GradientConfig</code> <p>Configuration for gradient calculations.</p> <code>realization_filters</code> <code>tuple[RealizationFilterConfig, ...]</code> <p>Configuration of realization filters.</p> <code>function_estimators</code> <code>tuple[FunctionEstimatorConfig, ...]</code> <p>Configuration of function estimators.</p> <code>samplers</code> <code>tuple[SamplerConfig, ...]</code> <p>Configuration of samplers.</p> <code>original_inputs</code> <code>dict[str, Any] | None</code> <p>The original input to the constructor.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.EnOptConfig.transforms","title":"<code>transforms</code>  <code>property</code>","text":"<p>Return the transforms.</p> <p>Returns:</p> Type Description <code>OptModelTransforms | None</code> <p>A transforms object or None.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.VariablesConfig","title":"<code>VariablesConfig</code>","text":"<p>The configuration class for variables.</p> <p>This configuration class, configured by the <code>variables</code> field in an <code>EnOptConfig</code> object defines essential aspects of the variables: the initial values and the bounds. These are given by the <code>initial_values</code>, <code>lower_bounds</code>, and <code>upper_bounds</code> fields, which are <code>numpy</code> arrays. Initial values must be provided, and its length determines the number of variables. The lower and upper bounds, are broadcasted to the number of variables, and are set to \\(-\\infty\\) and \\(+\\infty\\) by default. They may contain <code>numpy.nan</code> values, indicating that corresponding variables have no lower or upper bounds, respectively. These values are converted to <code>numpy.inf</code> values with an appropriate sign.</p> <p>The optional <code>types</code> field can be used to assign types to each variable, according to the <code>VariableType</code> enumeration. The values can be used to configure the optimizer accordingly. If not provided, all variables are assumed to be continuous and of real data type (corresponding to <code>VariableType.REAL</code>)</p> <p>The boolean entries of the optional <code>mask</code> field indicates which variables are considered to be free to change. During optimization, only these variables should change while others remain fixed.</p> <p>Attributes:</p> Name Type Description <code>types</code> <code>ArrayEnum | None</code> <p>The type of the variables (optional).</p> <code>initial_values</code> <code>Array1D</code> <p>The initial values of the variables.</p> <code>lower_bounds</code> <code>Array1D</code> <p>Lower bound of the variables (default: \\(-\\infty\\)).</p> <code>upper_bounds</code> <code>Array1D</code> <p>Upper bound of the variables (default: \\(+\\infty\\)).</p> <code>mask</code> <code>Array1DBool | None</code> <p>Optional mask of variables to optimize.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.ObjectiveFunctionsConfig","title":"<code>ObjectiveFunctionsConfig</code>","text":"<p>The configuration class for objective functions.</p> <p>This configuration class defines objective functions configured by the <code>objectives</code> field in an <code>EnOptConfig</code> object.</p> <p><code>ropt</code> supports optimization over multiple objectives, which are summed after weighting with values passed via the <code>weights</code> field. This field is a <code>numpy</code> array, with a length that determines the number of objective functions. Its values will be normalized to have a sum equal to 1. For example, when <code>weights</code> is set to <code>[1, 1]</code>, the stored values will be <code>[0.5, 0.5]</code>.</p> <p>The objective functions may be subject to realization filters and function estimators. The <code>realization_filters</code> and <code>function_estimators</code> fields contain indices to the realization filter or function estimator objects to use. The objects referred to are configured in the parent <code>EnOptConfig</code> object.</p> <p>Attributes:</p> Name Type Description <code>weights</code> <code>Array1D</code> <p>Objective functions weights (default: 1.0).</p> <code>realization_filters</code> <code>Array1DInt | None</code> <p>Optional realization filter indices.</p> <code>function_estimators</code> <code>Array1DInt | None</code> <p>Optional function estimator indices.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.LinearConstraintsConfig","title":"<code>LinearConstraintsConfig</code>","text":"<p>The configuration class for linear constraints.</p> <p>This class defines linear constraints configured by the <code>linear_constraints</code> field in an <code>EnOptConfig</code> object.</p> <p>Linear constraints can be described by a set of linear equations on the variables, including equality or non-equality constraints. The <code>coefficients</code> field is a 2D <code>numpy</code> array where the number of rows equals the number of constraints, and the number of columns equals the number of variables.</p> <p>Lower and upper bounds on he right-hand sides of the equations are given in the <code>lower_bounds</code> and <code>upper_bounds fields, which will be converted and broadcasted to a</code>numpy` array with a length equal to the number of equations.</p> <p>Attributes:</p> Name Type Description <code>coefficients</code> <code>Array2D</code> <p>The matrix of coefficients.</p> <code>lower_bounds</code> <code>Array1D</code> <p>The lower bounds on the right-hand-sides of the constraint equations.</p> <code>upper_bounds</code> <code>Array1D</code> <p>The upper bounds on the right-hand-sides of the constraint equations.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.LinearConstraintsConfig.apply_transformation","title":"<code>apply_transformation(variables, context)</code>","text":"<p>Transform linear constraints.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>VariablesConfig</code> <p>A variables configuration object specifying.</p> required <code>context</code> <code>EnOptContext | None</code> <p>The configuration context.</p> required <p>Returns:</p> Type Description <code>LinearConstraintsConfig</code> <p>A modified configuration if transformations are applied; otherwise, self.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.NonlinearConstraintsConfig","title":"<code>NonlinearConstraintsConfig</code>","text":"<p>The configuration class for non-linear constraints.</p> <p>This class defines non-linear constraints configured by the <code>nonlinear_constraints</code> field in an <code>EnOptConfig</code> object.</p> <p>Non-linear constraints require that some constraint function is compared to a right-hand-side value, either for equality or inequality. The <code>lower_bounds</code> and <code>upper_bounds</code> fields, which is a <code>numpy</code> arrays with a length equal to the number of constraint functions, provides the bounds on the right-hand-side values.</p> <p>The non-linear constraints may be subject to realization filters and function estimators. The <code>realization_filters</code> and <code>function_estimator</code> fields contain indices to the realization filter or function estimator objects to use. These objects are configured in the parent <code>EnOptConfig</code> object.</p> <p>Attributes:</p> Name Type Description <code>lower_bounds</code> <code>Array1D</code> <p>The lower bounds on the right-hand-side values.</p> <code>upper_bounds</code> <code>Array1D</code> <p>The upper bounds on the right-hand-side values.</p> <code>realization_filters</code> <code>Array1DInt | None</code> <p>Optional realization filter indices.</p> <code>function_estimators</code> <code>Array1DInt | None</code> <p>Optional function estimator indices.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.RealizationsConfig","title":"<code>RealizationsConfig</code>","text":"<p>The configuration class for realizations.</p> <p>This class defines realizations configured by the <code>realizations</code> field in an <code>EnOptConfig</code> object.</p> <p>To optimize an ensemble of functions, a set of realizations is defined. When the optimizer requests a function value or a gradient, the functions and gradients are calculated for each realization and combined into a single function or gradient. Usually, this will be a (weighted) sum, but other ways of combining realizations are possible.</p> <p>The <code>weights</code> field is a <code>numpy</code> array, with a length that determines the number of realizations. Its values will be normalized to have a sum equal to 1. For example, when <code>weights</code> is set to <code>[1, 1]</code>, the stored values will be <code>[0.5, 0.5]</code>.</p> <p>If during the calculation of the function values for each realization one or more values are missing, for instance due to failure of a complex simulation, the total function and gradient values can still be calculated by leaving the missing values out. However, this may be undesirable, or there may be a hard minimum to the amount of values that is needed. The <code>realization_min_success</code> field can be set to the minimum number of successful realizations. By default, it is set equal to the number of realizations, i.e., there are no missing values allowed by default.</p> Note <p>The value of <code>realization_min_success</code> can be set to zero. Some optimizers can handle this and will proceed with the optimization even if all realizations fail. However, most optimizers cannot handle this and will behave as if the value is set to one.</p> <p>Attributes:</p> Name Type Description <code>weights</code> <code>Array1D</code> <p>The weights of the realizations (default: 1).</p> <code>realization_min_success</code> <code>NonNegativeInt | None</code> <p>The minimum number of successful realizations                      (default: equal to the number of realizations).</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.OptimizerConfig","title":"<code>OptimizerConfig</code>","text":"<p>The configuration class for optimizers used in the optimization.</p> <p>This class defines the configuration for optimizers, configured by the <code>optimizer</code> field in an <code>EnOptConfig</code> object.</p> <p>Although there may be significant differences in the parameters that can be used for different optimization methods, there are a few standard settings defined in this configuration object, which are forwarded to the optimizer:</p> <ul> <li>The maximum number of iterations allowed before the optimization should be   aborted by this optimizer. The optimizer may choose to ignore this option.</li> <li>The maximum number of function evaluations allowed before the optimization   is aborted.</li> <li>The convergence tolerance used as a stopping criterion. The exact   definition of the criterion depends on the optimizer. The optimizer may   choose to ignore this option.</li> <li>Whether gradients should be evaluated early, even if the optimizer does   not strictly need it yet. When evaluating on a distributed HPC cluster,   this may lead to better load-balancing for some methods. This option is   only applied if the optimization algorithm knows how to make use of it.</li> <li>Whether calculations for functions and gradients should be done   separately, even if the optimizer requests them to be evaluated together.   This option is useful when a filter is specified that deactivates some   realizations (see   <code>RealizationFilterConfig</code>).   In this case, after evaluation of the functions, it may be possible to   reduce the number of evaluations for a following gradient calculation.</li> <li>Whether the optimizer may use parallelized function evaluations. This   option currently only applies to gradient-free methods and may be ignored   by the optimizer.</li> <li>An optional location of an output directory, where the optimizer may store   files.</li> <li>Generic optimizer options that may be passed as an arbitrary dictionary,   or as a list of strings. It depends on the method what form is required   and how it is interpreted.</li> </ul> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>Name of the optimization method used.</p> <code>max_iterations</code> <code>PositiveInt | None</code> <p>Optional maximum number of iterations.</p> <code>max_functions</code> <code>PositiveInt | None</code> <p>Optional maximum number of function evaluations.</p> <code>tolerance</code> <code>NonNegativeFloat | None</code> <p>Optional tolerance for convergence.</p> <code>speculative</code> <code>bool</code> <p>Force gradient evaluations; disabled if                split_evaluations is True (default <code>False</code>).</p> <code>split_evaluations</code> <code>bool</code> <p>Evaluate function and gradient separately                (default: <code>False</code>).</p> <code>parallel</code> <code>bool</code> <p>Allow for parallelized evaluation (default: <code>False</code>).</p> <code>output_dir</code> <code>Path | None</code> <p>Optional output directory for use by the optimizer.</p> <code>options</code> <code>dict[str, Any] | list[str] | None</code> <p>Optional generic options for use by the optimizer.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.GradientConfig","title":"<code>GradientConfig</code>","text":"<p>The configuration class for gradient calculations.</p> <p>This class defines the configuration for gradient calculations, configured by the <code>gradients</code> field in an <code>EnOptConfig</code> object.</p> <p>If the optimizer requires gradient information, it is estimated from a set of function values calculated from perturbed variables and from the unperturbed variables. The number of perturbations is determined by the <code>number_of_perturbations</code> field, which should be at least one and may be larger than the number of variables.</p> <p>Some function evaluations for the perturbed variables may fail, for instance due to an error in a long-running simulation. As long as not too many evaluations fail, the gradient may still be estimated. The <code>perturbation_min_success</code> field determines how many perturbed variables should be successfully evaluated. By default, this parameter is set equal to the number of perturbations.</p> <p>Perturbations are generally produced by sampler objects configured in the parent <code>EnOptConfig</code> object. The <code>samplers</code> field contains, for each variable, an index into the tuple of these configured samplers, indicating which sampler should be used to generate perturbation values for that variable. To support samplers that need random number, a random number generator object is created</p> <p>The generated perturbation values are added to the unperturbed variables after multiplication with the perturbation magnitudes given by the <code>perturbation_magnitudes</code> field. The perturbation values may be used directly or first modified in various ways. The <code>perturbation_types</code> field determines if and how this is done for each variable (see the <code>PerturbationType</code> enumeration for details).</p> <p>The perturbed variables can occasionally violate the bound constraints defined for the variables. This may be undesirable, for instance if the function evaluation may fail for variables that violate these constraints. The <code>boundary_types</code> array determines what action is taken to rectify such a situation (see the <code>BoundaryType</code> enumeration for more details).</p> <p>Both the <code>perturbation_types</code> and <code>boundary_types</code> fields are defined as integer arrays, but their values are limited to the values of the <code>PerturbationType</code> and <code>BoundaryType</code> enumerations, respectively.</p> <p>The gradient is calculated for each realization individually, and the resulting gradients are afterwards combined into a total gradient. If the number of perturbations is low, the calculation of the individual gradients may be unreliable. In particular, in the case of a single perturbation, the result is likely inaccurate. In such a case, the <code>merge_realizations</code> flag can be set to direct the optimizer to use a different calculation to combine the results of all realizations directly into an estimation of the total gradient.</p> <p>Attributes:</p> Name Type Description <code>number_of_perturbations</code> <code>PositiveInt</code> <p>The number of perturbations (default: <code>DEFAULT_NUMBER_OF_PERTURBATIONS</code>).</p> <code>perturbation_min_success</code> <code>PositiveInt | None</code> <p>The minimum number of successful function                       evaluations for perturbed variables (default:                       equal to the number of perturbations).</p> <code>perturbation_magnitudes</code> <code>Array1D</code> <p>The magnitudes of the perturbations for each variable                       (default: <code>DEFAULT_PERTURBATION_MAGNITUDE</code>).</p> <code>perturbation_types</code> <code>ArrayEnum</code> <p>The type of perturbation for each variable                       (<code>PerturbationType</code>,                       default: <code>DEFAULT_PERTURBATION_TYPE</code>).</p> <code>boundary_types</code> <code>ArrayEnum</code> <p>How perturbations that violate boundary conditions                       are treated (see <code>BoundaryType</code>),                       default: <code>DEFAULT_PERTURBATION_BOUNDARY_TYPE</code>).</p> <code>samplers</code> <code>Array1DInt | None</code> <p>The index of the sampler to use for each variable.</p> <code>seed</code> <code>ItemOrTuple[int]</code> <p>The seed for the random number generator passed to each sampler.</p> <code>merge_realizations</code> <code>bool</code> <p>If all realizations should be merged for the final                       gradient calculation (default: <code>False</code>).</p> The seed for samples <p>The seed controls consistency in results across repeated runs within the same plan, as long as the seed remains unchanged. To obtain unique results for each optimization run, the seed should be modified. The <code>numpy</code> manual suggests converting the seed to a tuple and pre-pending one or more unique integers.</p> <p>A suitable approach is to use the unique plan ID of the optimizer as the pre-pended value, which ensures reproducibility across nested and parallel plan evaluations.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.GradientConfig.fix_perturbations","title":"<code>fix_perturbations(variables, context)</code>","text":"<p>Adjust the gradient perturbation configuration.</p> <p>This method modifies the gradient's perturbation settings to account for variable bounds, as defined in the <code>variables</code> configuration. If bounds are set on the variables, the perturbations in the gradient configuration may need adjustment to reflect these constraints. This method returns an updated copy of the gradient configuration with the necessary modifications.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>VariablesConfig</code> <p>The configuration of variables.</p> required <code>context</code> <code>EnOptContext | None</code> <p>The configuration context.</p> required <p>Returns:</p> Type Description <code>GradientConfig</code> <p>A modified gradient configuration.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.FunctionEstimatorConfig","title":"<code>FunctionEstimatorConfig</code>","text":"<p>Configuration class for function estimators.</p> <p>This class defines the configuration for function estimators, which are configured by the <code>function_estimators</code> field in an <code>EnOptConfig</code> object. That field contains a tuple of configuration objects that define which function estimators are available during the optimization.</p> <p>By default, the final objective and constraint functions and their gradients are calculated from the individual realizations by a weighted sum. Function estimators are optionally used to modify this calculation.</p> <p>The <code>method</code> field determines which method will be used to implement the calculation of the final function or gradient from the individual realizations. To further specify how such a method should function, the <code>options</code> field can be used to pass a dictionary of key-value pairs. The interpretation of these options depends on the chosen method.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>The function estimator method.</p> <code>options</code> <code>dict[str, Any]</code> <p>Options to be passed to the estimator.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.RealizationFilterConfig","title":"<code>RealizationFilterConfig</code>","text":"<p>The configuration class for realization filters.</p> <p>This class defines the configuration for realization filters, which are configured by the <code>realization_filters</code> field in an <code>EnOptConfig</code> object. This field contains a tuple of configuration objects that define which realization filters are available during optimization.</p> <p>By default, the final objective and constraint functions and their gradients are calculated as a weighted function from all realizations. Realization filters are optionally used to change the weights of the individual realizations. For instance, this can be used to determine which subset of realizations should be used in calculating the final objective and constraint functions and their gradients by setting some weights to zero.</p> <p>The <code>method</code> field determines which method will be used to adjust the weights of the individual realizations. To further specify how such a method should function, the <code>options</code> field can be used to pass a dictionary of key-value pairs. The interpretation of these options depends on the| chosen method.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>The realization filter method.</p> <code>options</code> <code>dict[str, Any]</code> <p>Options to be passed to the filter.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.SamplerConfig","title":"<code>SamplerConfig</code>","text":"<p>The sampler configuration class.</p> <p>This class defines the configuration for samplers, which are configured by the <code>samplers</code> field in an <code>EnOptConfig</code> object. That field contains a tuple of configuration objects that define which samplers are available during the optimization. The <code>samplers</code> field in the gradient configuration (<code>GradientConfig</code>) is used to specify the index of the sampler for each variable.</p> <p>Gradients are calculated from a set of perturbed variables, which may be deterministic or stochastic in nature. These perturbations are generally produced by sampler objects that produce perturbation values to add to the unperturbed variables.</p> <p>Perturbation values are produced by a sampler, which provides the methods that can be used. The <code>method</code> field determines which sampler method will be used. To further specify how such a method should function, the <code>options</code> field can be used to pass a dictionary of key-value pairs. The interpretation of these options depends on the chosen method.</p> <p>By default, a different set of perturbed variables is generated for each realization. By setting the <code>shared</code> flag to <code>True</code>, the sampler can be directed to use the same set of perturbed values for each realization.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>The sampler method.</p> <code>options</code> <code>dict[str, Any]</code> <p>Options to be passed to the sampler.</p> <code>shared</code> <code>bool</code> <p>Whether perturbation values should be shared between realizations      (default: <code>False</code>).</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.constants","title":"<code>ropt.config.enopt.constants</code>","text":"<p>Default values used by the configuration classes.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.constants.DEFAULT_SEED","title":"<code>DEFAULT_SEED = 1</code>  <code>module-attribute</code>","text":"<p>Default random generator seed.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.constants.DEFAULT_NUMBER_OF_PERTURBATIONS","title":"<code>DEFAULT_NUMBER_OF_PERTURBATIONS = 5</code>  <code>module-attribute</code>","text":"<p>Default number of perturbations.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.constants.DEFAULT_PERTURBATION_MAGNITUDE","title":"<code>DEFAULT_PERTURBATION_MAGNITUDE = 0.005</code>  <code>module-attribute</code>","text":"<p>Default perturbation magnitude.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.constants.DEFAULT_PERTURBATION_BOUNDARY_TYPE","title":"<code>DEFAULT_PERTURBATION_BOUNDARY_TYPE = BoundaryType.MIRROR_BOTH</code>  <code>module-attribute</code>","text":"<p>Default perturbation boundary handling type.</p> <p>See also: <code>BoundaryType</code>.</p>"},{"location":"reference/enopt_config/#ropt.config.enopt.constants.DEFAULT_PERTURBATION_TYPE","title":"<code>DEFAULT_PERTURBATION_TYPE = PerturbationType.ABSOLUTE</code>  <code>module-attribute</code>","text":"<p>Default perturbation type.</p> <p>See also: <code>PerturbationType</code>.</p>"},{"location":"reference/enums/","title":"Enumerations","text":""},{"location":"reference/enums/#ropt.enums","title":"<code>ropt.enums</code>","text":"<p>Enumerations used within the <code>ropt</code> library.</p>"},{"location":"reference/enums/#ropt.enums.VariableType","title":"<code>VariableType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerates the variable types.</p> <p>The variable types are configured in the <code>variables</code> section of the optimizer configuration. The optimization backends may make us of this information to modify their behavior accordingly.</p>"},{"location":"reference/enums/#ropt.enums.VariableType.REAL","title":"<code>REAL = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Continuous variables represented by real values.</p>"},{"location":"reference/enums/#ropt.enums.VariableType.INTEGER","title":"<code>INTEGER = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Discrete variables represented by integer values.</p>"},{"location":"reference/enums/#ropt.enums.BoundaryType","title":"<code>BoundaryType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerates the ways boundaries should be treated.</p> <p>When variables are perturbed their values may violate boundary constraints. This enumeration lists the ways these values can be modified to fix this.</p>"},{"location":"reference/enums/#ropt.enums.BoundaryType.NONE","title":"<code>NONE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Do not modify the value.</p>"},{"location":"reference/enums/#ropt.enums.BoundaryType.TRUNCATE_BOTH","title":"<code>TRUNCATE_BOTH = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Truncate the value \\(v_i\\) at the lower or upper boundary (\\(l_i\\), \\(u_i\\)):</p> \\[ \\hat{v_i} = \\begin{cases}     l_i &amp; \\text{if $v_i &lt; l_i$}, \\\\     b_i &amp; \\text{if $v_i &gt; b_i$}, \\\\     v_i &amp; \\text{otherwise} \\end{cases} \\]"},{"location":"reference/enums/#ropt.enums.BoundaryType.MIRROR_BOTH","title":"<code>MIRROR_BOTH = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mirror the value \\(v_i\\) at the lower or upper boundary (\\(l_i\\), \\(u_i\\)):</p> \\[ \\hat{v_i} = \\begin{cases}     2l_i - v_i &amp; \\text{if $v_i &lt; l_i$}, \\\\     2b_i - v_i &amp; \\text{if $v_i &gt; b_i$}, \\\\     v_i        &amp; \\text{otherwise} \\end{cases} \\]"},{"location":"reference/enums/#ropt.enums.PerturbationType","title":"<code>PerturbationType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerates the types of perturbations that can be applied.</p> <p>When applying a perturbation to a variable, generally, some value is generated, which is then applied to the unperturbed values (usually by addition). This enumeration lists the ways how this perturbation value can be modified before being added to the unperturbed variable.</p>"},{"location":"reference/enums/#ropt.enums.PerturbationType.ABSOLUTE","title":"<code>ABSOLUTE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the perturbation value as is.</p>"},{"location":"reference/enums/#ropt.enums.PerturbationType.RELATIVE","title":"<code>RELATIVE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Multiply the perturbation value \\(p_i\\) by the range defined by the bounds of the variables \\(c_i\\): \\(\\hat{p}_i = (c_{i,\\text{max}} - c_{i,\\text{min}}) \\times p_i\\). The bounds will generally be defined in the configuration for the variables (see <code>VariablesConfig</code>).</p>"},{"location":"reference/enums/#ropt.enums.EventType","title":"<code>EventType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerates the events handled by the event broker.</p> <p>During the execution of the optimization plan, events may be emitted and callbacks can be connected to these events . When triggered by an event, the callbacks receive an <code>Event</code> object. This object contains at least the type of the event (a value of this enumeration) and the current configuration of the step that is executing. If the step has a name it is also added to the event. Additionally, depending on the event type, a tuple of result objects, an exit code  may be present. Refer to the documentation of the individual event types for details.</p>"},{"location":"reference/enums/#ropt.enums.EventType.START_EVALUATION","title":"<code>START_EVALUATION = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emitted before evaluating new functions.</p>"},{"location":"reference/enums/#ropt.enums.EventType.FINISHED_EVALUATION","title":"<code>FINISHED_EVALUATION = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emitted after finishing the evaluation.</p> <p>Results may be passed to callback reacting to this event.</p>"},{"location":"reference/enums/#ropt.enums.EventType.START_OPTIMIZER_STEP","title":"<code>START_OPTIMIZER_STEP = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emitted just before starting an optimizer step.</p>"},{"location":"reference/enums/#ropt.enums.EventType.FINISHED_OPTIMIZER_STEP","title":"<code>FINISHED_OPTIMIZER_STEP = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emitted immediately after an optimizer step finishes.</p> <p>Results and an exit code may be passed via the event object.</p>"},{"location":"reference/enums/#ropt.enums.EventType.START_EVALUATOR_STEP","title":"<code>START_EVALUATOR_STEP = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emitted just before starting an evaluation step.</p>"},{"location":"reference/enums/#ropt.enums.EventType.FINISHED_EVALUATOR_STEP","title":"<code>FINISHED_EVALUATOR_STEP = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Emitted immediately after an evaluation step finishes.</p> <p>Results and an exit code may be passed via the event object.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode","title":"<code>OptimizerExitCode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerates the reasons for terminating an optimization.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.UNKNOWN","title":"<code>UNKNOWN = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unknown cause of termination.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.TOO_FEW_REALIZATIONS","title":"<code>TOO_FEW_REALIZATIONS = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Returned when too few realizations are evaluated successfully.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.MAX_FUNCTIONS_REACHED","title":"<code>MAX_FUNCTIONS_REACHED = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Returned when the maximum number of function evaluations is reached.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.NESTED_OPTIMIZER_FAILED","title":"<code>NESTED_OPTIMIZER_FAILED = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Returned when a nested optimization fails to find an optimal value.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.USER_ABORT","title":"<code>USER_ABORT = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Returned when the optimization is aborted by the user.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.OPTIMIZER_STEP_FINISHED","title":"<code>OPTIMIZER_STEP_FINISHED = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Returned when an optimization step terminates normally.</p>"},{"location":"reference/enums/#ropt.enums.OptimizerExitCode.EVALUATION_STEP_FINISHED","title":"<code>EVALUATION_STEP_FINISHED = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Returned when an evaluation step terminates normally.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis","title":"<code>ResultAxis</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumerates the possible axes in a Results data object.</p> <p>Result objects (see <code>Results</code>) contain multidimensional arrays where the axes represent particular quantities, for instance variables, function objects, or realization numbers. The result objects contain metadata that identify the axes by values of this enumeration. These can be retrieved by the <code>get_axes</code> method of the attributes of a results object. They are used internally when exporting data to determine the type of the array axes, for instance to retrieve the names of the variables from the configuration.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis.VARIABLE","title":"<code>VARIABLE = 'variable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The axis index corresponds to the index of the variable.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis.OBJECTIVE","title":"<code>OBJECTIVE = 'objective'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The axis index corresponds to the index of the objective function.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis.LINEAR_CONSTRAINT","title":"<code>LINEAR_CONSTRAINT = 'linear_constraint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The axis index corresponds to the index of the linear constraint.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis.NONLINEAR_CONSTRAINT","title":"<code>NONLINEAR_CONSTRAINT = 'nonlinear_constraint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The axis index corresponds to the index of the constraint function.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis.REALIZATION","title":"<code>REALIZATION = 'realization'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The axis index corresponds to the index of the realization.</p>"},{"location":"reference/enums/#ropt.enums.ResultAxis.PERTURBATION","title":"<code>PERTURBATION = 'perturbation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The axis index corresponds to the index of the perturbation.</p>"},{"location":"reference/evaluator/","title":"Function Evaluations","text":""},{"location":"reference/evaluator/#ropt.ensemble_evaluator","title":"<code>ropt.ensemble_evaluator</code>","text":"<p>Functionality for the evaluation of ensembles.</p>"},{"location":"reference/evaluator/#ropt.ensemble_evaluator.EnsembleEvaluator","title":"<code>EnsembleEvaluator</code>","text":"<p>A class for constructing functions and gradients from an ensemble of functions.</p> <p>This class implements the calculation of functions and gradients from an ensemble of functions, based on the settings defined in an <code>EnOptConfig</code> configuration object. It uses an <code>Evaluator</code> callable to evaluate the individual functions.</p>"},{"location":"reference/evaluator/#ropt.ensemble_evaluator.EnsembleEvaluator.__init__","title":"<code>__init__(config, evaluator, plan_id, plugin_manager)</code>","text":"<p>Initialize the ensemble evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EnOptConfig</code> <p>The configuration object.</p> required <code>evaluator</code> <code>Evaluator</code> <p>The callable for evaluation individual functions.</p> required <code>plan_id</code> <code>tuple[int, ...]</code> <p>A tuple identifying the plan running this evaluator.</p> required <code>plugin_manager</code> <code>PluginManager</code> <p>A plugin manager to load required plugins.</p> required"},{"location":"reference/evaluator/#ropt.ensemble_evaluator.EnsembleEvaluator.calculate","title":"<code>calculate(variables, *, compute_functions, compute_gradients)</code>","text":"<p>Evaluate the given variable vectors.</p> <p>The <code>variables</code> argument may be a single vector of variables or a set of variable vectors represented as row-vectors in a matrix. The <code>compute_functions</code> and <code>compute_gradients</code> flags determine which results are returned: functions, gradients, or both.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>NDArray[float64]</code> <p>The variable vectors to evaluate.</p> required <code>compute_functions</code> <code>bool</code> <p>Whether to calculate functions.</p> required <code>compute_gradients</code> <code>bool</code> <p>Whether to calculate gradients.</p> required <p>Returns:</p> Type Description <code>tuple[Results, ...]</code> <p>The results for function evaluations and/or gradient evaluations.</p>"},{"location":"reference/evaluator/#ropt.evaluator","title":"<code>ropt.evaluator</code>","text":"<p>Function evaluation protocols and classes.</p>"},{"location":"reference/evaluator/#ropt.evaluator.Evaluator","title":"<code>Evaluator</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for evaluator objects or callables.</p> <p>The <code>EnsembleEvaluator</code> class requires a function evaluator callback that conforms to the <code>Evaluator</code> signature. This callback accepts one or more variable vectors to evaluate, along with an <code>EvaluatorContext</code> object that provides relevant information for the evaluation. It returns an <code>EvaluatorResult</code> object containing the results.</p>"},{"location":"reference/evaluator/#ropt.evaluator.Evaluator.__call__","title":"<code>__call__(variables, context)</code>","text":"<p>The function evaluator callback signature.</p> <p>The first argument of the function should be a matrix where each column is a variable vector. Depending on the information passed by the second argument, all objective and constraint functions for all vectors or for a subset are to be calculated.</p> <p>The second argument is an <code>EvaluatorContext</code> object that provides supplementary information to the evaluation function.</p> <p>The return value should be an <code>EvaluatorResult</code> object containing the calculated values of the objective and constraint functions for all variable vectors and realizations, along with any additional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>NDArray[float64]</code> <p>The matrix of variables to evaluate.</p> required <code>context</code> <code>EvaluatorContext</code> <p>The evaluation context.</p> required <p>Returns:</p> Type Description <code>EvaluatorResult</code> <p>An evaluation results object.</p> Reusing Objective <p>When defining multiple objectives, there may be a need to reuse the same objective value multiple times. For instance, a total objective could consist of the mean of the objectives for each realization, plus the standard deviation of the same values. This can be implemented by defining two objectives: the first calculated as the mean of the realizations, and the second using a function estimator to compute the standard deviations. The optimizer is unaware that both objectives use the same set of realizations. To prevent redundant calculations, the evaluator should compute the results of the realizations once and return them for both objectives.</p>"},{"location":"reference/evaluator/#ropt.evaluator.EvaluatorContext","title":"<code>EvaluatorContext</code>  <code>dataclass</code>","text":"<p>Capture additional details for the function evaluator.</p> <p>Function evaluator callbacks (see <code>Evaluator</code>) mainly require variable vectors to evaluate objective and constraint functions. However, depending on their implementation, evaluators may benefit from additional information. To accommodate this, function evaluators receive a <code>EvaluatorContext</code> object with the following details:</p> <ul> <li>The configuration object for the ongoing optimization step.</li> <li>Indices indicating the realization to which each variable vector belongs.</li> <li>Optional indices indicating which perturbation a variable vector is. This   index may be &lt; 0 to indicate that it is not a perturbation.</li> <li>A matrix indicating, for each function and realization, whether it is   active and needs computation.</li> <li>A matrix indicating, for each constraint and realization, whether it is   active and requires computation.</li> </ul> <p>The <code>active_objectives</code> and <code>active_constraints</code> fields are boolean matrices, where each column represents one realization, and each row signifies a function or a constraint. Entries marked as <code>True</code> are essential for the optimizer, while other combinations do not necessitate evaluation.</p> <p>In practical scenarios, these matrices may prove overly detailed for function evaluators. Typically, evaluators may only be capable of calculating all objective and constraint functions for a given realization or none at all. In such cases, it suffices to examine the <code>active</code> property, indicating the realizations requiring evaluation.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>EnOptConfig</code> <p>Configuration of the optimizer.</p> <code>realizations</code> <code>NDArray[intc]</code> <p>Realization numbers for each requested evaluation.</p> <code>perturbations</code> <code>NDArray[intc] | None</code> <p>Perturbations numbers for each requested evalation.</p> <code>active_objectives</code> <code>NDArray[bool_] | None</code> <p>Signifies which function/realization evaluations are                 essential for the optimizer.</p> <code>active_constraints</code> <code>NDArray[bool_] | None</code> <p>Signifies which constraint/realization evaluations are                 essential for the optimizer.</p> <code>active</code> <code>NDArray[bool_] | None</code> <p>Signifies which realizations are active.</p>"},{"location":"reference/evaluator/#ropt.evaluator.EvaluatorResult","title":"<code>EvaluatorResult</code>  <code>dataclass</code>","text":"<p>Store the results of a function evaluation.</p> <p>The objectives and constraint values are stored as a matrix, where the columns correspond to the index of the objective or constraint, and the rows correspond to the index of the variable vector for which they were calculated. Depending on context information passed to the evaluation function, not all results may have been calculated, in which case the corresponding entries should contain zeros. Entries may also contain <code>numpy.nan</code> values to signify that a calculation failed.</p> <p>Optionally, a batch ID can be returned to identify the batch of calculations. This can be useful for tracking or managing evaluations performed together.</p> <p>Additionally, evaluation IDs are provided as an option. These IDs can be used to uniquely identify the results calculated for each variable vector, offering a way to link specific evaluations back to their corresponding input vectors.</p> <p>Attributes:</p> Name Type Description <code>objectives</code> <code>NDArray[float64]</code> <p>The calculated objective values.</p> <code>constraints</code> <code>NDArray[float64] | None</code> <p>Optional calculated constraint values.</p> <code>batch_id</code> <code>int | None</code> <p>Optional batch ID.</p> <code>evaluation_ids</code> <code>NDArray[intc] | None</code> <p>Optional ID for each evaluation.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#ropt.exceptions","title":"<code>ropt.exceptions</code>","text":"<p>Exceptions raised within the <code>ropt</code> library.</p>"},{"location":"reference/exceptions/#ropt.exceptions.ConfigError","title":"<code>ConfigError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an configuration error occurs.</p>"},{"location":"reference/exceptions/#ropt.exceptions.OptimizationAborted","title":"<code>OptimizationAborted</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an optimization is aborted.</p> <p>When constructing the exception object an exit code must be passed that indicates the reason for aborting (see <code>OptimizerExitCode</code>).</p>"},{"location":"reference/exceptions/#ropt.exceptions.OptimizationAborted.__init__","title":"<code>__init__(exit_code)</code>","text":"<p>Initialize an exception that aborts the optimization.</p> <p>Parameters:</p> Name Type Description Default <code>exit_code</code> <code>OptimizerExitCode</code> <p>The exit code indicating the reason for the abort.</p> required"},{"location":"reference/external_optimizer_plugin/","title":"External Optimizer Plugin","text":""},{"location":"reference/external_optimizer_plugin/#ropt.plugins.optimizer.external.ExternalOptimizer","title":"<code>ropt.plugins.optimizer.external.ExternalOptimizer</code>","text":"<p>               Bases: <code>Optimizer</code></p> <p>Plugin class for optimization using an external process.</p> <p>This class enables optimization via an external process, which performs the optimization independently and communicates with this class over pipes to request function evaluations, report optimizer states, and handle any errors.</p> <p>Typically, the optimizer is specified within an <code>OptimizerConfig</code> via the <code>method</code> field, which either provides the algorithm name directly or follows the form <code>plugin-name/method-name</code>. In the first case, <code>ropt</code> searches among all available optimizer plugins to find the specified method. In the second case, it checks if the plugin identified by <code>plugin-name</code> contains <code>method-name</code> and, if so, uses it. Both of these are not supported by the external optimizer class. Instead, it requires that the <code>method</code> field includes both the plugin and method names in the format <code>external/plugin-name/method-name</code> or <code>external/method-name</code>. This ensures the external optimizer can identify and launch the specified optimization method <code>method-name</code> and launch it as an external process.</p>"},{"location":"reference/function_estimator_plugins/","title":"Function estimator Plugins","text":""},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator","title":"<code>ropt.plugins.function_estimator</code>","text":"<p>Plugin functionality for adding function estimators.</p> <p>This package contains the abstract base classes for function estimator plugins, and the default function estimators that are part of <code>ropt</code>.</p>"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base","title":"<code>ropt.plugins.function_estimator.base</code>","text":"<p>This module defines the abstract base classes for function estimators.</p> <p>Function estimators can be added via the plugin mechanism to implement additional ways to functions and gradient ensembles. Any object that adheres to the <code>FunctionEstimator</code> base class may be installed as a plugin.</p>"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base.FunctionEstimator","title":"<code>FunctionEstimator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for function estimators.</p>"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base.FunctionEstimator.__init__","title":"<code>__init__(enopt_config, estimator_index)</code>  <code>abstractmethod</code>","text":"<p>Initialize the function estimator object.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The configuration of the optimizer.</p> required <code>estimator_index</code> <code>int</code> <p>The index of the estimator to use.</p> required"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base.FunctionEstimator.calculate_function","title":"<code>calculate_function(functions, weights)</code>  <code>abstractmethod</code>","text":"<p>Combine functions from realizations into an expected function.</p> Calculation from merged realizations <p>Normally the gradient is calculated for each realization separately and then combined into an overall gradient with <code>calculate_gradient</code> method. The <code>merge_realizations</code> flag in the ensemble optimizer configuration directs the optimizer to calculate the overall gradient from all realizations directly. This yields a reasonable estimation if the function estimator is an averaging operation, but may not be appropriate in other cases.</p> <p>At initialization, the <code>merge_realizations</code> flag should be checked, and if necessary a <code>ConfigError</code> with an appropriate message should be raised.</p> <p>Parameters:</p> Name Type Description Default <code>functions</code> <code>NDArray[float64]</code> <p>The functions for each realization.</p> required <code>weights</code> <code>NDArray[float64]</code> <p>The weight of each realization.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The expected function values.</p>"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base.FunctionEstimator.calculate_gradient","title":"<code>calculate_gradient(functions, gradient, weights)</code>  <code>abstractmethod</code>","text":"<p>Combine gradients from realizations into an expected gradient.</p> <p>Parameters:</p> Name Type Description Default <code>functions</code> <code>NDArray[float64]</code> <p>The functions for each realization.</p> required <code>gradient</code> <code>NDArray[float64]</code> <p>The gradient for each realization.</p> required <code>weights</code> <code>NDArray[float64]</code> <p>The weight of each realization.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The expected gradients.</p>"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base.FunctionEstimatorPlugin","title":"<code>FunctionEstimatorPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>The function estimator plugin base class.</p>"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.base.FunctionEstimatorPlugin.create","title":"<code>create(enopt_config, estimator_index)</code>  <code>abstractmethod</code>","text":"<p>Initialize the function estimator object.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The configuration of the optimizer.</p> required <code>estimator_index</code> <code>int</code> <p>The index of the estimator to use.</p> required"},{"location":"reference/function_estimator_plugins/#ropt.plugins.function_estimator.default","title":"<code>ropt.plugins.function_estimator.default</code>","text":"<p>This module implements the default function estimator plugin.</p>"},{"location":"reference/optimization/","title":"Optimization","text":""},{"location":"reference/optimization/#ropt.optimization","title":"<code>ropt.optimization</code>","text":"<p>The main functionality for ensemble-based optimizations.</p> <p>The <code>EnsembleOptimizer</code> class provides the core functionality for running ensemble-based optimizations. Direct use of this class is generally discouraged; instead, the <code>Plan</code> or <code>BasicOptimizer</code> classes are recommended for more flexibility and ease of use.</p>"},{"location":"reference/optimization/#ropt.optimization.EnsembleOptimizer","title":"<code>EnsembleOptimizer</code>","text":"<p>Optimizer class for running ensemble optimizations.</p>"},{"location":"reference/optimization/#ropt.optimization.EnsembleOptimizer.is_parallel","title":"<code>is_parallel</code>  <code>property</code>","text":"<p>Check if the optimization is parallelized.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the optimization is parallelized; otherwise, False.</p>"},{"location":"reference/optimization/#ropt.optimization.EnsembleOptimizer.__init__","title":"<code>__init__(enopt_config, ensemble_evaluator, plugin_manager, signal_evaluation=None, nested_optimizer=None)</code>","text":"<p>Initialize the ensemble optimizer class.</p> <p>This class requires at least three arguments that together define a single optimization run:</p> <ol> <li>An <code>EnOptConfig</code> that contains all    configuration settings for the optimization.</li> <li>An <code>EnsembleEvaluator</code>    object responsible for evaluating functions.</li> <li>A <code>PluginManager</code> object that provides    access to optimizer plugins.</li> </ol> <p>Additionally, two optional callbacks can be provided:</p> <ol> <li>A <code>SignalEvaluationCallback</code>    that is called before and after each function evaluation.</li> <li>A <code>NestedOptimizerCallback</code>    that is called at each function evaluation to run a nested optimization.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The ensemble optimization configuration.</p> required <code>ensemble_evaluator</code> <code>EnsembleEvaluator</code> <p>The evaluator object for function evaluations.</p> required <code>plugin_manager</code> <code>PluginManager</code> <p>The plugin manager for accessing optimizer plugins.</p> required <code>signal_evaluation</code> <code>SignalEvaluationCallback | None</code> <p>Optional callback to signal evaluations.</p> <code>None</code> <code>nested_optimizer</code> <code>NestedOptimizerCallback | None</code> <p>Optional callback for running nested optimizations.</p> <code>None</code>"},{"location":"reference/optimization/#ropt.optimization.EnsembleOptimizer.start","title":"<code>start(variables)</code>","text":"<p>Start the optimization.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>NDArray[float64]</code> <p>The initial variables for the optimization.</p> required <p>Returns:</p> Type Description <code>OptimizerExitCode</code> <p>An exit code indicating the reason for termination.</p>"},{"location":"reference/optimization/#ropt.optimization.SignalEvaluationCallback","title":"<code>SignalEvaluationCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for a callback signaling the occurrence of an evaluation.</p> <p>This callback is invoked whenever an evaluation occurs, enabling custom handling or tracking of evaluation events.</p>"},{"location":"reference/optimization/#ropt.optimization.SignalEvaluationCallback.__call__","title":"<code>__call__(results=None, *, exit_code=None)</code>","text":"<p>Callback protocol for signaling the start and end of evaluations.</p> <p>When provided to an ensemble optimizer, this callback is invoked both before and after each evaluation. Prior to the start of an evaluation, this method is called with <code>results</code> set to <code>None</code>. Upon completion of the evaluation, it is called with <code>results</code> containing the evaluation output.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>tuple[Results, ...] | None</code> <p>The results produced by the evaluation, or <code>None</code> if the        evaluation has not yet completed.</p> <code>None</code> <code>exit_code</code> <code>OptimizerExitCode | None</code> <p>An exit code if that may be set if the evaluation completed.</p> <code>None</code>"},{"location":"reference/optimization/#ropt.optimization.NestedOptimizerCallback","title":"<code>NestedOptimizerCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for functions that start a nested optimization.</p>"},{"location":"reference/optimization/#ropt.optimization.NestedOptimizerCallback.__call__","title":"<code>__call__(variables)</code>","text":"<p>Callback protocol for executing a nested optimization.</p> <p>This function is called during each function evaluation within an ensemble optimizer to initiate a nested optimization process. It takes the current variables as arguments and returns a tuple containing the result of the nested optimization (or <code>None</code> if no result is available) and a boolean indicating whether the optimization was aborted by the user.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>NDArray[float64]</code> <p>The current variables to initialize the nested optimization.</p> required <p>Returns:</p> Type Description <code>tuple[FunctionResults | None, bool]</code> <p>The result of the nested optimization and a boolean indicating abortion.</p>"},{"location":"reference/optimizer_plugins/","title":"Optimizer Plugins","text":""},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer","title":"<code>ropt.plugins.optimizer</code>","text":"<p>Plugin functionality for adding optimization plugins.</p> <p>Optimization plugins are managed by a <code>PluginManager</code> object, which returns classes or factory functions to create objects that implement one or more optimization methods. These objects must adhere to the <code>Optimizer</code> abstract base class. This abstract base class allows <code>ropt</code> to provide the optimizer with the callback used for evaluating functions and gradients and allows it to be started from an optimizer step in the optimization plan.</p> <p>To support the implementation of the optimizer classes, the <code>ropt.plugins.optimizer.utils</code> module provides some utilities.</p> <p>By default the <code>SciPyOptimizer</code> plugin is installed which provides a number of methods from the <code>scipy.optimize</code> package.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base","title":"<code>ropt.plugins.optimizer.base</code>","text":"<p>This module defines base classes and protocols for optimization plugins.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.Optimizer","title":"<code>Optimizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base for optimizer classes.</p> <p>Optimizers provided by optimizer plugins should derive from the <code>Optimizer</code> abstract base class, which specifies the requirements for the class constructor (<code>__init__</code>) and also includes a <code>start</code> method used to initiate the optimization process.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.Optimizer.allow_nan","title":"<code>allow_nan</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return <code>True</code> if a <code>NaN</code> is a valid function value.</p> <p>If the optimizer can handle <code>NaN</code> function values, it may implement this method to return <code>True</code>. This enables handling cases where all function evaluations in an ensemble fail. By setting the <code>realization_min_success</code> configuration parameter to zero, the ensemble optimization plan can then be allowed to return a <code>NaN</code> value instead of raising an error.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>NaN</code> is allowed.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.Optimizer.is_parallel","title":"<code>is_parallel</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Whether the current uses parallel evaluations.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if optimization is parallelized.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.Optimizer.__init__","title":"<code>__init__(config, optimizer_callback)</code>  <code>abstractmethod</code>","text":"<p>Initialize an optimizer object.</p> <p>The <code>config</code> object provides the desired configuration for the optimization process and should be used to set up the optimizer correctly before starting the optimization. The optimization will be initiated using the <code>start</code> method and will repeatedly require function and gradient evaluations at given variable vectors. The <code>optimizer_callback</code> argument provides the function that should be used to calculate the function and gradient values, which can then be forwarded to the optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EnOptConfig</code> <p>The optimizer configuration to used.</p> required <code>optimizer_callback</code> <code>OptimizerCallback</code> <p>The optimizer callback.</p> required"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.Optimizer.start","title":"<code>start(initial_values)</code>  <code>abstractmethod</code>","text":"<p>Start the optimization.</p> <p>This method must be implemented to run the optimization using the provided initial values, collecting function and gradient evaluations as needed by calling the callback passed via the <code>optimizer_callback</code> argument during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>initial_values</code> <code>NDArray[float64]</code> <p>Vector of variables to start the optimization with.</p> required"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.OptimizerCallback","title":"<code>OptimizerCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for the optimizer callback.</p> <p>Optimization plugins implement optimizer classes derived from the <code>Optimizer</code> abstract base class. Objects of these classes are initialized with a callback function that follows the call signature defined here. This callback should be used to request the function and gradient evaluations that the optimizer needs.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.OptimizerCallback.__call__","title":"<code>__call__(variables, /, *, return_functions, return_gradients)</code>","text":"<p>The signature of the optimizer callback.</p> <p>The optimizer callback expects a vector or matrix with variables to evaluate. Discrete optimizers may request function evaluations for multiple variable vectors, passed as the rows of a matrix. Gradient-based methods may currently only pass a single variable vector at a time.</p> <p>The <code>return_functions</code> and <code>return_gradients</code> flags determine whether functions and/or gradients are to be evaluated. The results are returned as a tuple of arrays, one for functions and constraints, the other for gradients. If one of <code>return_functions</code> or <code>return_gradients</code> is <code>False</code>, the corresponding result is an empty array.</p> <p>Multiple function evaluations are returned as a matrix where the rows are the result vectors for each evaluation. The first element of a result vector is the value of the objective value, and the remaining elements are the values of the non-linear constraints.</p> <p>The gradients of the objective function and the non-linear constraints are returned as a matrix. The first row contains the gradient of the objective function, while the remaining rows contain the gradients of the non-linear constraints. Gradient-based methods currently support only a single evaluation, hence there is also only a single result.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>NDArray[float64]</code> <p>The variable vector or matrix to evaluate.</p> required <code>return_functions</code> <code>bool</code> <p>If <code>True</code>, evaluate and return functions.</p> required <code>return_gradients</code> <code>bool</code> <p>If <code>True</code>, evaluate and return gradients.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[float64], NDArray[float64]]</code> <p>A tuple with function and gradient values.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.OptimizerPlugin","title":"<code>OptimizerPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>Abstract base class for optimizer plugins.</p> <p>Optimizers are implemented through optimizer plugins that must derive from this base class. Plugins can be built-in, installed via a plugin mechanism, or loaded dynamically. During execution of an optimization plan, the required optimizer plugin will be located via the <code>PluginManager</code> and used to create <code>Optimizer</code> objects via its <code>create</code> function.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.base.OptimizerPlugin.create","title":"<code>create(config, optimizer_callback)</code>  <code>abstractmethod</code>","text":"<p>Create an optimizer.</p> <p>This is a factory function for instantiating optimizer objects implemented in the plugin.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EnOptConfig</code> <p>The optimizer configuration to used.</p> required <code>optimizer_callback</code> <code>OptimizerCallback</code> <p>The optimizer callback.</p> required"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils","title":"<code>ropt.plugins.optimizer.utils</code>","text":"<p>Utility functions for use by optimizer plugins.</p> <p>This module provides utility functions to validate supported constraints, filter linear constraints, and to retrieve the list of supported optimizers.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints","title":"<code>NormalizedConstraints</code>","text":"<p>Class for handling normalized constraints.</p> <p>This class can be used to normalize non-linear constraints into the form C(x) = 0, C(x) &lt;= 0, or C(x) &gt;= 0. By default this is done by subtracting the right-hand side value, and multiplying with -1, if necessary.</p> <p>The right hand sides are provided by the <code>lower_bounds</code> and <code>upper_bound</code> values. If corresponding entries in these arrays are equeal (within a 1e-15 tolerance), the corresponding constraint is assumed to be a equality constraint. If they are not, they are considered inequality constraints, if one or both values are finite. If the lower bounds are finite, the constraint is added as is, after subtracting of the lower bound. If the upper bound is finite, the same is done, but the constraint is multiplied by -1. If both are finite, both constraints are added, effectively splitting a two-sided constraint into two normalized constraints.</p> <p>By default this normalizes inequality constraints to the form C(x) &lt; 0, by setting <code>flip</code> flag, this can be changed to C(x) &gt; 0.</p> Usage <ol> <li>Initialize with the lower and upper bounds.</li> <li>Before each new function/gradient evaluation with a new variable    vector, reset the normalized constraints by calling the <code>reset</code>    method.</li> <li>The constraint values are given by the <code>constraints</code> property. Before    accessing it, call the <code>set_constraints</code> with the raw constraints. If    necessary, this will calculate and cache the normalized values. Since    values are cached, calling this method and accessing <code>constraints</code>    multiple times is cheap.</li> <li>Use the same procedure for gradients, using the <code>gradients</code> property    and <code>set_gradients</code>. Raw gradients must be provided as a matrix,    where the rows are the gradients of each constraint.</li> <li>Use the <code>is_eq</code> property to retrieve a vector of boolean flags to    check which constraints are equality constraints.</li> </ol> <p>See the <code>scipy</code> optimization backend in the <code>ropt</code> source code for an example of usage.</p> Parallel evaluation. <p>The raw constraints may be a vector of constraints, or may be a matrix of constraints for multiple variables to support parallel evaluation. In the latter case, the constraints for different variables are given by the columns of the matrix. In this case, the <code>constraints</code> property will have the same structure. Note that this is only supported for the constraint values, not for the gradients. Hence, parallel evaluation of multiple gradients is not supported.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.is_eq","title":"<code>is_eq</code>  <code>property</code>","text":"<p>Return the flags that indicate equality transforms.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.constraints","title":"<code>constraints</code>  <code>property</code>","text":"<p>Return the normalized constraints.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The normalized constraints.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.gradients","title":"<code>gradients</code>  <code>property</code>","text":"<p>Return the normalized constraint gradients.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The normalized constraint gradients.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.__init__","title":"<code>__init__(lower_bounds, upper_bounds, *, flip=False)</code>","text":"<p>Initialize the normalization class.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bounds</code> <code>NDArray[float64]</code> <p>The lower bounds on the right hand sides.</p> required <code>upper_bounds</code> <code>NDArray[float64]</code> <p>The upper bounds on the right hand sides.</p> required <code>flip</code> <code>bool</code> <p>Whether to flip the sign of the constraints.</p> <code>False</code>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.reset","title":"<code>reset()</code>","text":"<p>Reset the constraints and its gradients.</p>"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.set_constraints","title":"<code>set_constraints(values)</code>","text":"<p>Set the constraints property.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>NDArray[float64]</code> <p>The raw constraint values.</p> required"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.NormalizedConstraints.set_gradients","title":"<code>set_gradients(values)</code>","text":"<p>Set the normalized and gradients.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>NDArray[float64]</code> <p>The raw gradient values.</p> required"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.validate_supported_constraints","title":"<code>validate_supported_constraints(config, method, supported_constraints, required_constraints)</code>","text":"<p>Check if the requested optimization features are supported or required.</p> <p>The keys of the supported_constraints and required_constraints dicts specify the type of the constraint as shown in the example below. The values are sets of method names that support or require the type of constraint specified by the key.</p> <p>For example: {     \"bounds\": {\"L-BFGS-B\", \"TNC\", \"SLSQP\"},     \"linear:eq\": {\"SLSQP\"},     \"linear:ineq\": {\"SLSQP\"},     \"nonlinear:eq\": {\"SLSQP\"},     \"nonlinear:ineq\": {\"SLSQP\"}, }</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>EnOptConfig</code> <p>The ensemble optimizer configuration object.</p> required <code>method</code> <code>str</code> <p>The method to check.</p> required <code>supported_constraints</code> <code>dict[str, set[str]]</code> <p>Specify the supported constraints.</p> required <code>required_constraints</code> <code>dict[str, set[str]]</code> <p>Specify the required constraints.</p> required"},{"location":"reference/optimizer_plugins/#ropt.plugins.optimizer.utils.create_output_path","title":"<code>create_output_path(base_name, base_dir=None, name=None, suffix=None)</code>","text":"<p>Create an output path name.</p> <p>If the path already exists, an index is appended to it.</p> <p>Parameters:</p> Name Type Description Default <code>base_name</code> <code>str</code> <p>Base name of the path.</p> required <code>base_dir</code> <code>Path | None</code> <p>Optional directory to base the path in.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional optimization step name to include in the name.</p> <code>None</code> <code>suffix</code> <code>str | None</code> <p>Optional suffix for the resulting path.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>The constructed path</p>"},{"location":"reference/plan/","title":"Optimization Plans","text":""},{"location":"reference/plan/#ropt.plan","title":"<code>ropt.plan</code>","text":"<p>Code for executing optimization plans.</p> <p>The <code>Plan</code> class is responsible for executing optimization plans, accepting optional input values and returning output values. The plan's configuration is managed by the <code>PlanConfig</code> class, which specifies the inputs, outputs, variables, steps, and result handlers.</p> <p>A plan comprises <code>PlanStep</code> objects that define individual actions, as well as <code>ResultHandler</code> objects that process and store data generated during execution. Both steps and result handlers are implemented through a <code>plugin</code> mechanism, making it easy to extend the range of supported steps and result handlers. The <code>ropt</code> library also includes a default plan plugin that provides various steps and result handlers to support a broad range of optimization workflows.</p> <p>Most optimization plans require shared state across all steps, such as a callable for function evaluations or a random number generator. This shared state is provided through an <code>OptimizerContext</code> object, which is supplied when creating the plan.</p> <p>Setting up and executing a plan object for simple optimization cases can be complex. The <code>BasicOptimizer</code> class simplifies this process by providing a convenient way to build and execute straightforward plans involving a single optimization.</p>"},{"location":"reference/plan/#ropt.plan.Plan","title":"<code>Plan</code>","text":"<p>The plan class for executing optimization workflows.</p>"},{"location":"reference/plan/#ropt.plan.Plan.aborted","title":"<code>aborted</code>  <code>property</code>","text":"<p>Check if the plan was aborted by the user.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the plan was aborted by the user; otherwise, <code>False</code>.</p>"},{"location":"reference/plan/#ropt.plan.Plan.plan_id","title":"<code>plan_id</code>  <code>property</code>","text":"<p>Return the ID of the plan.</p> <p>Each plan has a unique ID, stored as a tuple of integers, which reflects both its creation order and any nesting structure within the plan hierarchy. When a plan spawns additional plans, this hierarchy is encoded in the <code>plan_id</code> attribute as a sequential tuple.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[int, ...]</code> <p>The unique tuple-based ID for this plan.</p>"},{"location":"reference/plan/#ropt.plan.Plan.optimizer_context","title":"<code>optimizer_context</code>  <code>property</code>","text":"<p>Return the optimizer context associated with the plan.</p> <p>This method retrieves the optimizer context object that provides shared state and functionality for executing the optimization plan.</p> <p>Returns:</p> Type Description <code>OptimizerContext</code> <p>The optimizer context object used by the plan.</p>"},{"location":"reference/plan/#ropt.plan.Plan.__init__","title":"<code>__init__(config, optimizer_context, parent=None, plan_id=None)</code>","text":"<p>Initialize a plan object.</p> <p>This method initializes a plan using a <code>PlanConfig</code> object and an <code>OptimizerContext</code> object. An optional <code>plugin_manager</code> argument allows for the specification of custom plugins for result handlers and step objects within the plan. If omitted, only plugins installed through Python's standard entry points are used.</p> <p>Plans can spawn additional plans within their workflow, with each spawned plan receiving a reference to its parent plan via the <code>parent</code> argument.</p> <p>Plan hierarchies are tracked using the <code>plan_id</code> attribute, a tuple of integers. A directly created plan has <code>plan_id == (0,)</code>. When a plan spawns a new plan with the <code>spawn</code> method, the child receives an incremental index appended to its parent's <code>plan_id</code>, forming a unique sequence that reflects both the order of creation and nesting. This structure enables efficient tracing across both sequential and nested plan workflows.</p> <p>If the <code>optimizer_context</code> objects has variables defined, these are copied into the plan and available under the name they were added to the context. These variables can then be modified, but when spawning new plans, the new plan will have the original values for these variables.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PlanConfig</code> <p>The configuration for the optimizer.</p> required <code>optimizer_context</code> <code>OptimizerContext</code> <p>The context in which the plan will execute,                providing shared resources across steps.</p> required <code>parent</code> <code>Plan | None</code> <p>Optional reference to the parent plan that                spawned this plan.</p> <code>None</code> <code>plan_id</code> <code>tuple[int, ...] | None</code> <p>The ID of the plan, reflecting its hierarchy.</p> <code>None</code>"},{"location":"reference/plan/#ropt.plan.Plan.run","title":"<code>run(*args)</code>","text":"<p>Run the Plan.</p> <p>This method accepts an arbitrary number of inputs that are stored in the plan variables that are specified in the <code>inputs</code> section of the plan <code>configuration</code>. The number of arguments must be equal to the number elements in that section otherwise an error will be raised.</p> <p>After execution of the steps, this method will return the contents of the plan variables that are specified in the <code>outputs</code> section of the plan <code>configuration</code> as a tuple.</p>"},{"location":"reference/plan/#ropt.plan.Plan.abort","title":"<code>abort()</code>","text":"<p>Abort the plan.</p>"},{"location":"reference/plan/#ropt.plan.Plan.create_steps","title":"<code>create_steps(step_configs)</code>","text":"<p>Instantiate step objects from step configurations.</p> <p>This method takes a list of step configuration objects and creates a corresponding list of initialized step objects, each configured based on its respective configuration.</p> <p>Parameters:</p> Name Type Description Default <code>step_configs</code> <code>list[PlanStepConfig]</code> <p>List of configuration objects defining each step.</p> required <p>Returns:</p> Type Description <code>list[PlanStep]</code> <p>List of configured step objects ready for execution in the plan.</p>"},{"location":"reference/plan/#ropt.plan.Plan.run_steps","title":"<code>run_steps(steps)</code>","text":"<p>Execute a list of steps in the plan.</p> <p>This method iterates through and executes a provided list of plan steps. If execution is interrupted by the user, it returns <code>True</code> to indicate an aborted run.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>list[PlanStep]</code> <p>A list of steps to be executed sequentially.</p> required <p>Returns:</p> Type Description <code>None</code> <p><code>True</code> if execution was aborted by the user; otherwise, <code>False</code>.</p>"},{"location":"reference/plan/#ropt.plan.Plan.spawn","title":"<code>spawn(config)</code>","text":"<p>Spawn a new plan from the current plan.</p> <p>This method creates a new plan that shares the same optimization context and plugin manager as the current plan. However, it does not inherit other properties, such as variables.</p> <p>Any signals emitted within the spawned plan are forwarded to the result handlers of the current plan and to the connected observers. In other words, signals emitted by the spawned plan will \"bubble up\" to the current plan.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PlanConfig</code> <p>The configuration for the new plan.</p> required <p>Returns:</p> Type Description <code>Plan</code> <p>A new plan object configured with the provided configuration.</p>"},{"location":"reference/plan/#ropt.plan.Plan.eval","title":"<code>eval(expr)</code>","text":"<p>Evaluate the provided expression.</p> <p>If the input is a string, it is evaluated as an expression. Refer to the <code>eval</code> method of the <code>ExpressionEvaluator</code> class for more details.</p> <p>If the input is a list, tuple or a dictionary, the eval method is recursively called on all values it contains, replacing any strings that are expressions with the results.</p> <p>If the input is not a string, list, tuple, or dictionary it is returned unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Any</code> <p>The expression to evaluate, as a string or any other type.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The evaluated result, which may vary in type depending on the context.</p>"},{"location":"reference/plan/#ropt.plan.Plan.emit_event","title":"<code>emit_event(event)</code>","text":"<p>Emit an event of the specified type with the provided data.</p> <p>When this method is called, the following steps are executed:</p> <ol> <li>All event handlers associated with the plan are invoked, which may    modify the event.</li> <li>If the plan has no parent, all observer functions registered for the    specified event type via the <code>add_observer</code> method are called.</li> <li>If the plan was spawned from another plan, the <code>emit_event</code> method of    the parent plan is also called, but only if at least one of the tags    in the event is present in the <code>bubble_up</code> section of the plan    configuration.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event object to emit.</p> required"},{"location":"reference/plan/#ropt.plan.Plan.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Get the value of a plan variable.</p> <p>This method implements the <code>[]</code> operator on the plan object to retrieve the value associated with a specific plan variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable whose value is to be retrieved.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the specified variable, which can be of any type.</p>"},{"location":"reference/plan/#ropt.plan.Plan.__setitem__","title":"<code>__setitem__(name, value)</code>","text":"<p>Set a plan variable to the given value.</p> <p>This method implements the <code>[]</code> operator on the plan object to set the value of a specific plan variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable to set.</p> required <code>value</code> <code>Any</code> <p>The value to assign to the variable.</p> required"},{"location":"reference/plan/#ropt.plan.Plan.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Check if a variable exists.</p> <p>This method implements the <code>in</code> operator on the plan object to determine if a plan variable exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the variable exists; otherwise, <code>False</code>.</p>"},{"location":"reference/plan/#ropt.plan.OptimizerContext","title":"<code>OptimizerContext</code>","text":"<p>Context class for shared state across a plan.</p> <p>An optimizer context object holds the information and state shared across all steps in an optimization plan. This currently includes the following:</p> <ul> <li>An <code>Evaluator</code> callable for evaluating   functions.</li> <li>An expression evaluator object for processing expressions.</li> <li>A plugin manager to retrieve plugins used by the plan and optimizers.</li> <li>Event callbacks that are triggered in response to specific events,   executed after the plan has processed them.</li> <li>Variables with a constant value that are copied into each plan created   with the context.</li> </ul>"},{"location":"reference/plan/#ropt.plan.OptimizerContext.__init__","title":"<code>__init__(evaluator, plugin_manager=None, variables=None)</code>","text":"<p>Initialize the optimization context.</p> <p>Initializes shared state and resources needed across an optimization plan, including a function evaluator and an optional expression evaluator for processing plan-specific expressions.</p> <p>Parameters:</p> Name Type Description Default <code>evaluator</code> <code>Evaluator</code> <p>A callable used to evaluate functions within the plan.</p> required <code>plugin_manager</code> <code>PluginManager | None</code> <p>Optional plugin manager.</p> <code>None</code> <code>variables</code> <code>dict[str, Any] | None</code> <p>Optional constant plan variable definitions.</p> <code>None</code>"},{"location":"reference/plan/#ropt.plan.OptimizerContext.add_observer","title":"<code>add_observer(event, callback)</code>","text":"<p>Add an observer function.</p> <p>Observer functions are called during optimization when an event of the specified type occurs. The provided callable must accept a single argument of the <code>Event</code> class, which contains information about the occurred event.</p> Note <p>Before the observer functions are called, all result handlers are executed, which may potentially modify the event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventType</code> <p>The type of events that the observer will react to.</p> required <code>callback</code> <code>Callable[[Event], None]</code> <p>The function to call when the specified event is received.       This function should accept one argument, which will be       an instance of the <code>Event</code> class.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Self, to allow for method chaining.</p>"},{"location":"reference/plan/#ropt.plan.OptimizerContext.call_observers","title":"<code>call_observers(event)</code>","text":"<p>Call observers for a specified event.</p> <p>This method invokes all observers associated with the context for the type of event passed as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event that is emitted.</p> required"},{"location":"reference/plan/#ropt.plan.ExpressionEvaluator","title":"<code>ExpressionEvaluator</code>","text":"<p>A class for evaluating mathematical expressions in strings.</p>"},{"location":"reference/plan/#ropt.plan.ExpressionEvaluator.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the expression evaluator.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if any provided function overrides a built-in.</p>"},{"location":"reference/plan/#ropt.plan.ExpressionEvaluator.add_functions","title":"<code>add_functions(functions)</code>","text":"<p>Add functions to the evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>functions</code> <code>dict[str, Callable[..., Any]] | None</code> <p>A dictionary of functions to add.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a function already exists.</p>"},{"location":"reference/plan/#ropt.plan.ExpressionEvaluator.eval","title":"<code>eval(expr, variables)</code>","text":"<p>Evaluate an expression string with provided variable values.</p> <p>The <code>expr</code> string is evaluated according to the following rules:</p> <ol> <li> <p>Strings containing substrings delimited by <code>&lt;&lt;...&gt;&gt;</code> are treated as    templates. The content of each <code>&lt;&lt;...&gt;&gt;</code> instance is evaluated as an    expression, and the result replaces the <code>&lt;&lt;...&gt;&gt;</code> substring.</p> </li> <li> <p>Strings containing single <code>$</code> characters, or enclosed in <code>$(...)</code>,    are evaluated as expressions. Expressions can access the variables    passed through the <code>variables</code> parameter, by prefixing them in the    expression with a <code>$</code> sign. A set of built-in functions, and    additional functions added using the    <code>add_functions</code> method    can also be used in an expression.</p> </li> </ol> Expressions only containing literals <p>If an expression has no variables, you need to enclose it in <code>$(...)</code> delimiters, like so: <code>$(1 + 1)</code>, or <code>$(max(1, 2))</code>.</p> String Interpolation with <code>&lt;&lt;...&gt;&gt;</code>: <p>Use the <code>&lt;&lt;...&gt;&gt;</code> notation when the overall result should be a string. Expressions within <code>&lt;&lt;...&gt;&gt;</code> do not require <code>$(...)</code> delimiters: <code>\"&lt;&lt;1 + 1&gt;&gt;\"</code> will evaluate to <code>\"2\"</code>, but variables must still be prefixed with <code>$</code>, for example <code>\"&lt;&lt;$x + 1&gt;&gt;\"</code>.</p> <p>Examples of valid expressions, assuming <code>x == 1</code> and <code>y ==2</code>:</p> Expression Result <code>$(1 + 1)</code> 2 <code>$(max(1, 2))</code> 2 <code>$x</code> 1 <code>$x + 1</code> 2 <code>$x + $y</code> 3 <code>max(1, $y)</code> 2 Supported Features**: <ul> <li>Supported Python operators include standard mathematical, boolean,   and comparison operations.</li> <li>Literal types supported: <code>int</code>, <code>float</code>, <code>bool</code>, and <code>str</code>. Nested   lists (<code>[...]</code>) and dictionaries (<code>{...}</code>) are supported and can   reference variables or call functions within them.</li> <li>Allowed types in expressions include numbers, strings, dicts,   lists, <code>numpy</code> arrays, <code>Results</code>, and   <code>EnOptConfig</code> objects.</li> <li>Built-in functions include: <code>abs</code>, <code>bool</code>, <code>divmod</code>, <code>float</code>,   <code>int</code>, <code>max</code>, <code>min</code>, <code>pow</code>, <code>range</code>, <code>round</code>, <code>sum</code>, <code>str</code>.</li> </ul> <p>Plan variables may contain objects of any type. However, to be used in an expression, they should contain a value of a supported type or be convertible to a supported type before evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression to evaluate, provided as a string.</p> required <code>variables</code> <code>Mapping[str, Any]</code> <p>A dictionary containing the variable values.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The result of evaluating the expression.</p>"},{"location":"reference/plan/#ropt.plan.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>The <code>Event</code> class stores optimization event data.</p> <p>While running an optimization plan, callbacks can be connected to react to events triggered during execution. These callbacks accept a single <code>Event</code> object containing information about the event.</p> <p>The actual data contained in the object depends on the nature of the event. Refer to the documentation of the <code>EventType</code> enumeration for more details.</p> <p>Attributes:</p> Name Type Description <code>event_type</code> <code>EventType</code> <p>The type of the event.</p> <code>tags</code> <code>set[str]</code> <p>Optional tags added to the results.</p> <code>plan_id</code> <code>tuple[int, ...]</code> <p>The ID of the plan that generated the event.</p> <code>data</code> <code>dict[str, Any]</code> <p>Optional data passed with the event.</p>"},{"location":"reference/plan_config/","title":"Optimization Plan Configuration","text":""},{"location":"reference/plan_config/#ropt.config.plan","title":"<code>ropt.config.plan</code>","text":"<p>Configuration classes for optimization plans.</p> <p>The <code>PlanConfig</code> class, based on Pydantic, configures optimization workflows managed by the <code>Plan</code> class. Alongside defining variables for the plan, <code>PlanConfig</code> utilizes <code>PlanStepConfig</code> and <code>ResultHandlerConfig</code> classes to structure the steps and result handlers that define a complete workflow.</p>"},{"location":"reference/plan_config/#ropt.config.plan.PlanConfig","title":"<code>PlanConfig</code>","text":"<p>Configuration class for optimization plans.</p> <p>This class configures the workflows managed by a <code>Plan</code> object, specifying key sections that define the plan's behavior and data flow. Each section aligns with a distinct aspect of the optimization plan:</p> <code>inputs</code> Specifies the names of plan variables to hold input values when the   optimization workflow is started using the <code>run</code>   method. <code>outputs</code> Lists the names of plan variables whose final values will be returned as a   tuple when the optimization completes and the <code>run</code> method finishes. <code>bubble_up</code> Lists the tags of results that should be bubbled up to the parent plan (if   present). <code>variables</code> Defines a dictionary of plan variable names and initial values, used   during plan execution. <code>steps</code> Outlines each step executed once the plan begins Steps support a variety   of actions, such as initiating an optimization, accessing or modifying   variables, and emitting events. Emitted events are processed by the   handlers specified in the <code>results</code> section. <code>handlers</code> Specifies the event handlers that process events emitted by steps.   Handlers receive events sequentially, with each handler passing events to   the next in the chain. <p>Attributes:</p> Name Type Description <code>inputs</code> <code>list[str]</code> <p>List of input variable names.</p> <code>outputs</code> <code>list[str]</code> <p>List of output variable names.</p> <code>bubble_up</code> <code>set[str]</code> <p>List of tags denoting results that should be bubbled up.</p> <code>variables</code> <code>dict[str, Any]</code> <p>Dictionary of variable names with initial values.</p> <code>steps</code> <code>list[PlanStepConfig]</code> <p>List of steps defining plan actions.</p> <code>handlers</code> <code>list[ResultHandlerConfig]</code> <p>List of result handler instances.</p>"},{"location":"reference/plan_config/#ropt.config.plan.PlanStepConfig","title":"<code>PlanStepConfig</code>","text":"<p>Configuration for a single step within an optimization plan.</p> <p>A step represents a single action in the optimization process. It can access and modify plan variables, execute tasks such as optimization runs, and emit <code>events</code>, for example, when intermediate optimization results are generated.</p> <p>The <code>run</code> string specifies the code that executes the step, and is used by the plugin manager to load the appropriate code.</p> <p>Additional parameters required by the step can be configured using the <code>with_</code> attribute, with its content varying based on the step type.</p> <p>Execution of the step can be made conditional by providing an expression through the <code>if_</code> attribute. This expression is evaluated, and the step is executed only if the result is <code>True</code>.</p> <code>with</code> and <code>if</code> aliases <p>When parsing dictionaries into a <code>StepConfig</code> object, replace the <code>with_</code> attribute with <code>with</code>, and <code>if_</code> with <code>if</code> (without the underscore).</p> Conditional evaluation <p>Conditions specified via the <code>if_</code> attribute are evaluated using the <code>eval</code> method of the plan object executing the steps. Refer to the method's documentation for more information on supported expressions.</p> <p>While mathematical expressions are generally evaluated using the <code>$eval()</code> function, this is optional for expressions passed via the <code>if_</code> attribute. For instance, <code>$eval(x &gt; 0)</code> and <code>x &gt; 0</code> are equivalent values for the <code>if_</code> attribute.</p> Alternative specification of the step config. <p>The standard format for defining a step configuration follows the attribute-based structure shown here. Typically, a dictionary initializing a step would resemble:</p> <pre><code>{\n    \"run\": \"optimizer\",\n    \"with\": {\n        \"config\": \"$opt_config\",\n        \"tags\": \"opt\",\n    }\n    \"if\": \"x &gt; 0\"\n}\n</code></pre> <p>However, a pre-processing step allows a short-hand alternative notation, converting it into the above format before constructing the configuration object:</p> <pre><code>{\n    \"optimizer\": {\n        \"config\": \"$opt_config\",\n        \"tags\": \"opt\",\n    }\n    \"if\": \"x &gt; 0\"\n}\n\nFor very simple steps that have only a single configuration field, this may\neven be simpler by just providing the value, like this:\n\n```python\n{\n    \"print\": \"hello world!\",\n}\n</code></pre> <p>However, whereas first short-hand approach is generic and works for all steps, this last form may or may not be implemented the step. Consult the step documentation to make sure it works.</p> <p>Attributes:</p> Name Type Description <code>run</code> <code>str</code> <p>Specifies the code that runs the step.</p> <code>with_</code> <code>list[Any] | dict[str, Any] | str</code> <p>Additional parameters passed to the step.</p> <code>if_</code> <code>str | None</code> <p>An optional expression for conditional execution.</p>"},{"location":"reference/plan_config/#ropt.config.plan.ResultHandlerConfig","title":"<code>ResultHandlerConfig</code>","text":"<p>Configuration for a single result handler object.</p> <p>Result handler objects process events emitted by the steps of an optimization plan. These objects can receive <code>events</code> directly from the plan's steps, or from another result handler in a chain of handlers, as defined in the <code>results</code> section of a <code>PlanConfig</code> object. Upon receiving events, handlers may perform actions such as modifying plan variables, generating output, or updating the result objects included in the event.</p> <p>The <code>run</code> string specifies the code that initializes the result handler. This string is used by the plugin manager to load the handler's code.</p> <p>Additional parameters for the handler are configured using the <code>with_</code> attribute, which varies depending on the type of handler.</p> <code>with</code> is an alias for <code>with_</code> <p>When parsing dictionaries into a <code>ResultHandlerConfig</code> object, the <code>with_</code> attribute should be replaced by <code>with</code> (without the underscore).</p> Alternative specification of the result handler config. <p>The standard format for defining a result handler configuration follows the attribute-based structure shown here. Typically, a dictionary initializing a step would resemble:</p> <pre><code>{\n    \"run\": \"tracker,\n    \"with\": {\n        \"var\": \"result\",\n        \"tags\": \"opt\",\n    }\n}\n</code></pre> <p>However, a pre-processing step allows a short-hand alternative notation, converting it into the above format before constructing the configuration object:</p> <pre><code>{\n    \"tracker\": {\n        \"var\": \"result\",\n        \"tags\": \"opt\",\n    }\n}\n</code></pre> <p>Attributes:</p> Name Type Description <code>run</code> <code>str</code> <p>Specifies the code used to initialize the result handler.</p> <code>with_</code> <code>Any</code> <p>Additional parameters passed to the result handler.</p>"},{"location":"reference/plan_plugins/","title":"Plan Plugins","text":""},{"location":"reference/plan_plugins/#ropt.plugins.plan","title":"<code>ropt.plugins.plan</code>","text":"<p>Plugin functionality for adding plan objects.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base","title":"<code>ropt.plugins.plan.base</code>","text":"<p>This module defines the base classes for optimization plan plugins.</p> <p>Optimization plan steps and result handlers can be added via the plugin mechanism to implement additional functionality. This is done by creating a plugin class that derives from the <code>PlanPlugin</code> class. It needs to define a <code>create</code> method that generates the plan objects.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanStep","title":"<code>PlanStep</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for steps.</p> <p>steps loaded and created by the plugin manager must inherit from this abstract base class. It defines a <code>run</code> method that must be overridden to implement the specific functionality of each step. The class also provides default properties for accessing the configuration and the plan that executes the step.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanStep.step_config","title":"<code>step_config</code>  <code>property</code>","text":"<p>Return the step object's configuration.</p> <p>Returns:</p> Type Description <code>PlanStepConfig</code> <p>The configuration object.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanStep.plan","title":"<code>plan</code>  <code>property</code>","text":"<p>Return the plan that executes the step.</p> <p>Returns:</p> Type Description <code>Plan</code> <p>The plan object.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanStep.__init__","title":"<code>__init__(config, plan)</code>","text":"<p>Initialize the step.</p> <p>The <code>config</code> and <code>plan</code> arguments are accessible as <code>step_config</code> and <code>plan</code> properties.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PlanStepConfig</code> <p>The configuration for this step.</p> required <code>plan</code> <code>Plan</code> <p>The parent plan that manages this step.</p> required"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanStep.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Execute the step object.</p> <p>This method must be overloaded to implement the functionality of the step.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.ResultHandler","title":"<code>ResultHandler</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for result handler objects.</p> <p>Result handlers loaded and created by the plugin manager must inherit from this abstract base class. It defines a <code>handle_event</code> method that must be overridden to implement specific functionality and provides default properties for accessing the handler's configuration and the plan that runs it.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.ResultHandler.handler_config","title":"<code>handler_config</code>  <code>property</code>","text":"<p>Return the configuration of the handler object.</p> <p>Returns:</p> Type Description <code>ResultHandlerConfig</code> <p>The configuration object.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.ResultHandler.plan","title":"<code>plan</code>  <code>property</code>","text":"<p>Return the associated plan that executes the handler.</p> <p>Returns:</p> Type Description <code>Plan</code> <p>The plan object.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.ResultHandler.__init__","title":"<code>__init__(config, plan)</code>","text":"<p>Initialize a results handler.</p> <p>The <code>config</code> and <code>plan</code> arguments are accessible as <code>handler_config</code> and <code>plan</code> properties.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ResultHandlerConfig</code> <p>The configuration of the handler object.</p> required <code>plan</code> <code>Plan</code> <p>The parent plan that contains the object.</p> required"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.ResultHandler.handle_event","title":"<code>handle_event(event)</code>  <code>abstractmethod</code>","text":"<p>Handle and propagate an event.</p> <p>This method must be overloaded to implement the functionality of the handler, based on the information passed via the event object. The handler may modify the event, which may be propagated further to other handlers or to callbacks that react to the event.</p> <p>Returns:</p> Type Description <code>Event</code> <p>The event, possibly modified.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanPlugin","title":"<code>PlanPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>Abstract base class for plan plugins.</p> <p>This base class serves as the foundation for all plugins used in an optimization plan, including plan steps and result handlers. Any plugin derived from this class can be built-in, installed via a plugin mechanism, or dynamically loaded. During the execution of an optimization plan, the required plugin is located through the <code>PluginManager</code>, which then uses the plugin's <code>create</code> function to instantiate either a <code>PlanStep</code> or a <code>ResultHandler</code> as needed.</p> Plan functions <p>A plan plugin can also provide functions to be used by the plan<code>s expression evaluator. To achieve this, the plugin should override the</code>functions<code>property of the [</code>PlanPlugin`][ropt.plugins.plan.base.PlanPlugin] class. This property should return a dictionary that maps function names to callables, which are subsequently added to the expression evaluator.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanPlugin.functions","title":"<code>functions</code>  <code>property</code>","text":"<p>Return plan functions implemented by the plugin.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The functions.</p>"},{"location":"reference/plan_plugins/#ropt.plugins.plan.base.PlanPlugin.create","title":"<code>create(config, context)</code>  <code>abstractmethod</code>","text":"<p>Create a step or result handler.</p> <p>This factory function instantiates either a step or a result handler object based on the provided configuration. The configuration determines which type of object to return\u2014either a step or a result handler.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ResultHandlerConfig | PlanStepConfig</code> <p>The configuration for the plan object.</p> required <code>context</code> <code>OptimizerContext</code> <p>The context in which the plan operates.</p> required"},{"location":"reference/plan_runner/","title":"Basic Plan runner","text":""},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer","title":"<code>ropt.plan.BasicOptimizer</code>","text":"<p>A class for running optimization plans.</p> <p><code>BasicOptimizer</code> objects are designed for use cases where the optimization workflow comprises a single optimization run. Using this object can be more convenient than defining and running an optimization plan directly in such cases.</p> <p>This class provides the following features:</p> <ul> <li>Start a single optimization.</li> <li>Add observer functions connected to various optimization events.</li> <li>Attach metadata to each result generated during the optimization.</li> <li>Generate tables summarizing the optimization results.</li> </ul>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.results","title":"<code>results</code>  <code>property</code>","text":"<p>Return the optimal result.</p> <p>Returns:</p> Type Description <code>FunctionResults | None</code> <p>The optimal result found during optimization.</p>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.variables","title":"<code>variables</code>  <code>property</code>","text":"<p>Return the optimal variables.</p> <p>Returns:</p> Type Description <code>NDArray[float64] | None</code> <p>The variables corresponding to the optimal result.</p>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.exit_code","title":"<code>exit_code</code>  <code>property</code>","text":"<p>Return the exit code.</p> <p>Returns:</p> Type Description <code>OptimizerExitCode</code> <p>The exit code of the optimization run.</p>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.__init__","title":"<code>__init__(enopt_config, evaluator, *, constraint_tolerance=1e-10)</code>","text":"<p>Initialize an <code>BasicOptimizer</code> object.</p> <p>An optimization configuration and an evaluation object must be provided, as they define the optimization to perform.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>dict[str, Any] | EnOptConfig</code> <p>The configuration for the optimization.</p> required <code>evaluator</code> <code>Evaluator</code> <p>The evaluator object used to evaluate functions.</p> required <code>constraint_tolerance</code> <code>float</code> <p>The tolerance level used to detect constraint violations.</p> <code>1e-10</code>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.add_observer","title":"<code>add_observer(event_type, function)</code>","text":"<p>Add an observer.</p> <p>Observers are callables that are triggered when an optimization event occurs. This method adds an observer that responds to a specified event type.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>EventType</code> <p>The type of event to observe.</p> required <code>function</code> <code>Callable[[Event], None]</code> <p>The callable to invoke when the event is emitted.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The <code>BasicOptimizer</code> instance, allowing for method chaining.</p>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.add_event_data","title":"<code>add_event_data(data)</code>","text":"<p>Add data that will be merged into event data.</p> <p>The given data will be merged into the event data dictionary that is passed via events emitted by the optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The data to add.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The <code>BasicOptimizer</code> instance, allowing for method chaining.</p>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.run","title":"<code>run()</code>","text":"<p>Run the optimization.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The <code>BasicOptimizer</code> instance, allowing for method chaining.</p>"},{"location":"reference/plan_runner/#ropt.plan.BasicOptimizer.abort_optimization","title":"<code>abort_optimization()</code>  <code>staticmethod</code>","text":"<p>Abort the current optimization run.</p> <p>This method can be called from within callbacks to interrupt the ongoing optimization plan. The exact point at which the optimization is aborted depends on the step that is executing at that point. For example, within a running optimizer, the process will be interrupted after completing the current function evaluation.</p>"},{"location":"reference/plugin_manager/","title":"Plugins","text":""},{"location":"reference/plugin_manager/#ropt.plugins","title":"<code>ropt.plugins</code>","text":"<p>The <code>plugins</code> module facilitates the integration of <code>ropt</code> plugins.</p> <p>The core functionality of <code>ropt</code> can be extended through plugins, which can either be builtin, separately installed, or dynamically added at runtime. Currently, <code>ropt</code> supports the following plugin types to implement specific types of functionality:</p> <code>optimizer</code>: Plugins that implement specific optimization methods. The builtin   <code>scipy</code> plugin utilizes the   <code>scipy.optimize</code> module to implement various optimization algorithms. <code>sampler</code>: Plugins responsible for generating perturbations for estimating gradients.   The builtin <code>scipy</code> plugin is based   on <code>scipy.stats</code>,   providing various sampling methods. <code>realization_filter</code>: These plugins implement filters for selecting a sub-set of realizations used   in calculating objective or constraint functions and their gradients. The   included   <code>default</code>   plugin provides filters based on ranking and for CVaR optimization. <code>function_estimator</code>: These plugins calculate the final objective and gradient from sets of   objectives or constraints and their gradients for individual realizations. The   included   <code>default</code>   plugin supports objectives defined by the mean or standard deviation of these   values. <code>plan</code>: Plan plugins implement the objects that execute an optimization plan.   The built-in <code>default</code> plugin   offers a full set of optimization plan objects for executing complex   optimization plans. <p>Plugins are managed by the <code>PluginManager</code> class. This class is used to retrieve plugin objects that derive from an abstract base class defining the required functionality for each plugin type:</p> <ol> <li><code>OptimizerPlugin</code>:     Abstract base class for optimizer plugins.</li> <li><code>SamplerPlugin</code>:     Abstract base class for sampler plugins.</li> <li><code>RealizationFilterPlugin</code>:     Abstract base class for realization filter plugins.</li> <li><code>FunctionEstimatorPlugin</code>:     Abstract base class for function estimator plugins.</li> <li><code>PlanPlugin</code>:     Abstract base class for optimization plan object plugins.</li> </ol> <p>Plugins can be built-in, installed separately using the standard entry points mechanism, or added dynamically using the <code>add_plugin</code> method.</p> <p>The plugin manager object provides the <code>get_plugin</code> method, which <code>ropt</code> uses to retrieve the necessary plugin based on its type and name. Given the plugin's type and name, this method returns a callable (either a class or a factory function) that <code>ropt</code> uses to instantiate the plugin when needed.</p> Plugin and method names <p>Plugins are registered by name by plugin manager objects. Plugins may implement multiple methods, each of which should also be identified by a name. <code>PluginManager.get_plugin</code> and <code>PluginManager.is_supported</code> accept method names and will search through the available plugins to find the correct plugin code. To refer to a method method-name of a given plugin plugin-name, a string in the form \"plugin-name/method-name\" can be used instead. In this case, the plugin manager will not search through all plugins for the requested method but will only inquire with the plugin plugin-name. By convention, using \"default\" for the method name in such a string will select the default method of the plugin.</p>"},{"location":"reference/plugin_manager/#ropt.plugins.PluginManager","title":"<code>PluginManager</code>","text":"<p>The plugin manager.</p>"},{"location":"reference/plugin_manager/#ropt.plugins.PluginManager.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the plugin manager.</p> <p>The plugin manager object is initialized via the entry points mechanism (see <code>importlib.metadata</code>).</p> <p>For instance, to install an additional optimizer plugin, implemented in an independent package, and assuming installation via a <code>pyproject.toml</code> file, add the following:</p> <p><pre><code>[project.entry-points.\"ropt.plugins.optimizer\"]\nmy_optimizer = \"my_optimizer_pkg.my_plugin:MyOptimizer\"\n</code></pre> This will make the <code>MyOptimizer</code> class from the <code>my_optimizer_pkg</code> package available under the name <code>my_optimizer</code>. The <code>MyOptimizer</code> class will be used to create <code>Optimizer</code> objects and to facilitate this, it should derive from the <code>OptimizerPlugin</code> class.</p> <p>Plugins can also be added dynamically using the <code>add_plugin</code> method.</p>"},{"location":"reference/plugin_manager/#ropt.plugins.PluginManager.add_plugin","title":"<code>add_plugin(plugin_type, name, plugin, *, prioritize=False)</code>","text":"<p>Add a plugin at runtime.</p> <p>This method adds a plugins of a specific type to the plugin manager. Normally it will be added at the end of the internal list of plugins that may be searched for a method. However, if the <code>prioritize</code> keyword is set, it will be added at the beginning of the list.</p> <p>The plugin names are case-insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_type</code> <code>PluginType</code> <p>Type of the plugin.</p> required <code>name</code> <code>str</code> <p>The name of the plugin.</p> required <code>plugin</code> <code>Plugin</code> <p>The plugin object.</p> required <code>prioritize</code> <code>bool</code> <p>If <code>True</code>, the plugin will be added to the beginning of list.</p> <code>False</code>"},{"location":"reference/plugin_manager/#ropt.plugins.PluginManager.get_plugin","title":"<code>get_plugin(plugin_type, method)</code>","text":"<p>Retrieve a plugin by type and method name.</p> <p>If the method name is of the form \"plugin-name/method-name\", the method method-name will be retrieved from the given plugin plugin-name.</p> <p>If the given method name does not contain a slash (/), the plugin manager will search through all plugins and return the first plugin that supports the requested method. Searching occurs in the order that plugins were added to the manager, which normally will be one of the plugins loaded via entry points, but plugins added dynamically can be prioritized.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_type</code> <code>PluginType</code> <p>The type of the plugin to retrieve.</p> required <code>method</code> <code>str</code> <p>The name of the method the plugin should provide.</p> required"},{"location":"reference/plugin_manager/#ropt.plugins.PluginManager.is_supported","title":"<code>is_supported(plugin_type, method)</code>","text":"<p>Check if a method is supported.</p> <p>If the given method name does not contain a slash (/), the plugin manager will search through all plugins and return <code>True</code> if a plugin is found that supports the requested method. If the method name is of the form \"plugin-name/method-name\", <code>True</code> will be returned if the method method-name is supported by the given plugin plugin-name.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_type</code> <code>PluginType</code> <p>The type of the plugin to retrieve.</p> required <code>method</code> <code>str</code> <p>The name of the method the plugin should provide.</p> required"},{"location":"reference/plugin_manager/#ropt.plugins.PluginManager.plugins","title":"<code>plugins(plugin_type)</code>","text":"<p>Generate a sequence of all plugins of a specified type.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_type</code> <code>PluginType</code> <p>The type of plugins to return.</p> required <p>Yields:</p> Type Description <code>tuple[str, Plugin]</code> <p>A tuple of the plugin name and object.</p>"},{"location":"reference/plugin_manager/#ropt.plugins.PluginType","title":"<code>PluginType = Literal['optimizer', 'sampler', 'realization_filter', 'function_estimator', 'plan']</code>  <code>module-attribute</code>","text":"<p>Plugin Types Supported by <code>ropt</code></p>"},{"location":"reference/plugin_manager/#ropt.plugins.Plugin","title":"<code>Plugin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for plugins.</p> <p><code>ropt</code>  plugins should derive from this base class, which specifies an <code>is_supported</code> method.</p>"},{"location":"reference/plugin_manager/#ropt.plugins.Plugin.is_supported","title":"<code>is_supported(method)</code>  <code>abstractmethod</code>","text":"<p>Check whether a given method is supported.</p> <p>This method is called by the <code>is_supported</code> method of <code>PluginManager</code> objects to verify if a specific method is supported by this plugin.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The name of the method to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the method is supported; otherwise, False.</p>"},{"location":"reference/plugin_manager/#ropt.plugins.Plugin.allows_discovery","title":"<code>allows_discovery</code>  <code>property</code>","text":"<p>Check if the plugin can be discovered automatically.</p> <p>Normally, plugins may be discovered automatically by the plugin manager by checking if they support a specific method. However, some plugins may not support this behavior and should be explicitly requested. These should override this property to return <code>False</code>.</p> <p>For example, the <code>external</code> optimizer plugin does not define its own methods but launches methods from other plugins as an external process. Therefore, the <code>external</code> optimizer plugin must always be specified explicitly, and this method is overloaded to return False.</p>"},{"location":"reference/realization_filter_plugins/","title":"Realization Filter Plugins","text":""},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter","title":"<code>ropt.plugins.realization_filter</code>","text":"<p>Plugin functionality for adding realization filters.</p> <p>This package contains the abstract base class for realization filter plugins, and the default realization filters that are part of <code>ropt</code>.</p> <p>Realization filters are used by the optimizer to determine how a set of realizations should be used to calculate objective and constraint function values. They do this by calculating the weights that should be used for each realization when calculating the values of a given set of objectives and constraints.</p>"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.base","title":"<code>ropt.plugins.realization_filter.base</code>","text":"<p>This module defines the abstract base class for realization filters.</p> <p>Realization filters can be added via the plugin mechanism to implement additional ways to filter the realizations that are used to calculate functions and gradients. Any object that derives from the <code>RealizationFilter</code> abstract base class may be installed as a plugin.</p>"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.base.RealizationFilter","title":"<code>RealizationFilter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for realization filter classes.</p>"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.base.RealizationFilter.__init__","title":"<code>__init__(enopt_config, filter_index)</code>  <code>abstractmethod</code>","text":"<p>Initialize the realization filter plugin.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The configuration of the optimizer.</p> required <code>filter_index</code> <code>int</code> <p>The index of the filter to use.</p> required"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.base.RealizationFilter.get_realization_weights","title":"<code>get_realization_weights(objectives, constraints)</code>  <code>abstractmethod</code>","text":"<p>Return the updated weights of the realizations.</p> <p>This method is called by the optimizer with the current values of the objectives and constraints. Based on these values it must decide how much weight each realization should be given, and return those as a vector.</p> <p>The objectives and the constraints are passed as matrices, where the columns contain the values of the objectives or constraints. The index along the row axis corresponds to the number of the realization.</p> Normalization <p>The weights will be normalized to a sum of one by the optimizer before use, hence any non-negative weight value is permissable.</p> <p>Parameters:</p> Name Type Description Default <code>objectives</code> <code>NDArray[float64]</code> <p>The objectives of all realizations.</p> required <code>constraints</code> <code>NDArray[float64] | None</code> <p>The constraints for all realizations.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A vector of weights of the realizations.</p>"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.base.RealizationFilterPlugin","title":"<code>RealizationFilterPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>Abstract base class for realizationFilter plugins.</p>"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.base.RealizationFilterPlugin.create","title":"<code>create(enopt_config, filter_index)</code>  <code>abstractmethod</code>","text":"<p>Initialize the realization filter plugin.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The configuration of the optimizer.</p> required <code>filter_index</code> <code>int</code> <p>The index of the filter to use.</p> required"},{"location":"reference/realization_filter_plugins/#ropt.plugins.realization_filter.default","title":"<code>ropt.plugins.realization_filter.default</code>","text":"<p>This plugin contains realization filters that are installed by default.</p>"},{"location":"reference/reporting/","title":"Reporting","text":""},{"location":"reference/reporting/#ropt.report","title":"<code>ropt.report</code>","text":"<p>Classes for reporting optimization results.</p> <p>The classes in this module are designed to gather multiple results generated during the execution of an optimization plan. Currently, the results can be reported as a <code>pandas</code> DataFrame using the <code>ResultsDataFrame</code> class, or as a text file in a tabular format using the <code>ResultsTable</code> class.</p>"},{"location":"reference/reporting/#ropt.report.ResultsDataFrame","title":"<code>ResultsDataFrame</code>","text":"<p>Generate a results report in a <code>pandas</code> DataFrame.</p> <p>The class is intended to be used for gathering results from <code>Results</code> objects and storing them as a <code>pandas</code> DataFrame.</p> <p>New results can be added to the stored DataFrame as they become available using the <code>add_results</code> method. The content of the DataFrame is taken from the fields of the <code>Results</code> object passed during each call to <code>add_results</code>. The updated table can be retrieved at any time via the <code>frame</code> property.</p>"},{"location":"reference/reporting/#ropt.report.ResultsDataFrame.frame","title":"<code>frame</code>  <code>property</code>","text":"<p>Return the function results generated so far.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas data frame with the results.</p>"},{"location":"reference/reporting/#ropt.report.ResultsDataFrame.__init__","title":"<code>__init__(fields, *, table_type='functions')</code>","text":"<p>Initialize a ResultsDataFrame object.</p> <p>The set of fields used is determined by the <code>results_fields</code> argument passed when initializing the object. These can be any of the fields defined in a <code>FunctionResults</code> or a <code>GradientResults</code>. Most of the fields in these objects are nested, and the fields to export must be specified specifically in the form <code>field.subfield</code>. For instance, to specify the <code>variables</code> field of the <code>evaluations</code> field from a function result, the specification would be <code>evaluations.variables</code>.</p> <p>Note that many fields may, in fact, generate multiple columns in the resulting data frame. For instance, when specifying <code>evaluations.variables</code>, a column will be generated for each variable. If available, variable names, will be used as column labels. Because the exported fields may be multi-dimensional with names defined along each axis, for instance, realizations and objectives, which both can be named, the final name may consist of a tuple of names.</p> <p>The <code>table_type</code> argument is used to determine which type of results should be reported: either function evaluation results (<code>functions</code>) or gradient results (<code>gradients</code>).</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>set[str]</code> <p>The fields of the results to store.</p> required <code>table_type</code> <code>Literal['functions', 'gradients']</code> <p>The type of the table.</p> <code>'functions'</code>"},{"location":"reference/reporting/#ropt.report.ResultsDataFrame.add_results","title":"<code>add_results(results, names=None)</code>","text":"<p>Add a results object to the table.</p> <p>This method can be called directly from any observers connected to events that produce results.</p> <p>The <code>names</code> argument is an optional dictionary that maps axis types to names, that are used to label the multi-index columns in the resulting data frame. If not provided, numerical indices are used.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>Results</code> <p>The results to add.</p> required <code>names</code> <code>dict[str, Sequence[str | int] | None] | None</code> <p>A dictionary mapping axis types to names.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if a result was added, else False</p>"},{"location":"reference/reporting/#ropt.report.ResultsTable","title":"<code>ResultsTable</code>","text":"<p>               Bases: <code>ResultsDataFrame</code></p> <p>Generate files containing tables of optimization results.</p> <p>This class derives from the <code>ResultsDataFrame</code> class and writes the generated data frame in a tabular format to a text file.</p>"},{"location":"reference/reporting/#ropt.report.ResultsTable.__init__","title":"<code>__init__(columns, path, *, table_type='functions', min_header_len=None)</code>","text":"<p>Initialize a results table.</p> <p>The <code>columns</code> parameter specifies which results are to be exported. The keys of the <code>columns</code> dictionary correspond to the <code>fields</code> parameter of the <code>ResultsDataFrame</code> parent class. The values are the corresponding titles of the columns of the table that is generated. As described in the documentation of the parent class, a single field may generate multiple columns, each with unique names (i.e., variable names). These are handled by adding the name to the column name below the main title. As a result, the header may consist of multiple lines, and the number of lines may vary according to requested fields. For a consistent result, the minimum number of header lines can be specified via the <code>min_header_len</code> argument. When needed, blank lines will be added to reach the specified minimum number of header lines.</p> Reading the generated file. <p>The resulting table can be read using a reader that can handle fixed-width columns, such as the read_fwf function of pandas. However, the header will need to skip a number of header lines. The min_header_len argument can be used to set the minimum number of lines in the header. If the generated header has fewer lines than min_header_len, empty lines will be added. For example:</p> <pre><code># For a table generated with `min_header_len=3`:\nresults = pd.read_fwf(\n    \"results.txt\",\n    header=list(range(3)),\n    skip_blank_lines=False,\n    skiprows=[3],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>dict[str, str]</code> <p>Mapping of column names for the results table.</p> required <code>path</code> <code>Path</code> <p>Path of the result file.</p> required <code>table_type</code> <code>Literal['functions', 'gradients']</code> <p>Type of the table.</p> <code>'functions'</code> <code>min_header_len</code> <code>int | None</code> <p>Minimal number of header lines.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the pandas or tabulate modules are not                  available</p>"},{"location":"reference/reporting/#ropt.report.ResultsTable.save","title":"<code>save()</code>","text":"<p>Write the table to a file.</p>"},{"location":"reference/results/","title":"Optimization Results","text":""},{"location":"reference/results/#ropt.results","title":"<code>ropt.results</code>","text":"<p>Data classes for storing intermediate optimization results.</p> <p>During the optimization process, functions and gradients are calculated and need to be reported. To streamline this process, new results are passed to callbacks as a tuple of <code>Results</code> objects. These may be instances of the derived <code>FunctionResults</code> or <code>GradientResults</code> classes, which contain results for function and gradient evaluations, respectively.</p> <p>Much of the data stored in the result objects is multi-dimensional. For example, the <code>objectives</code> field, which is part of the nested <code>evaluations</code> object in the <code>FunctionResults</code>, is a two-dimensional <code>numpy</code> array. In this array, columns correspond to the objectives, and rows correspond to the realization numbers.</p> <p>To facilitate exporting and reporting results, the identity of the axes in such multi-dimensional arrays is stored in metadata associated with the corresponding field. These fields derive from the <code>ResultField</code> class, which includes a <code>get_axes</code> class method to retrieve the axes. For example, for the <code>objectives</code> field, this method retrieves the axes:</p> <pre><code>&gt;&gt;&gt; from ropt.results import FunctionEvaluations\n&gt;&gt;&gt; FunctionEvaluations.get_axes(\"objectives\")\n(&lt;ResultAxis.REALIZATION: 'realization'&gt;, &lt;ResultAxis.OBJECTIVE: 'objective'&gt;)\n</code></pre> <p>Using this metadata, the exporting or reporting code can refer to the optimizer configuration to associate realization and objective names with any entry in the result matrix. For instance, the <code>pandas</code> exporting code will utilize this information to construct a multi-index for the generated DataFrame and may also unstack such multi-dimensional data into multiple columns.</p>"},{"location":"reference/results/#ropt.results.Results","title":"<code>ropt.results.Results</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The <code>Results</code> class serves as an abstract base class for storing results.</p> <p>This class contains the following generic information:</p> <ol> <li>The plan ID, a tuple of integer values.</li> <li>An optional batch ID, which may be generated by the function evaluator.    The interpretation of this ID depends on the evaluator code. It is    intended to be used as a unique identifier for the group of function    evaluations passed to the evaluator by the optimization code.</li> <li>A dictionary of metadata to be added by optimization steps. This contains    generic information, the nature of which depends on the steps producing    them. They are expected to be primitive values not interpreted by the    optimization code but can be exported and reported.</li> </ol> <p>The <code>Results</code> class is an abstract base class that is not intended to be instantiated by itself. Most data of interest will be stored in additional fields in one of the derived classes: <code>FunctionResults</code> or <code>GradientResults</code>. In addition to the attributes containing the data, a few methods are provided to export the data. These functions will only be useful when used with one of the derived classes:</p> <ol> <li>The <code>to_dataframe</code> method can be    used to export the contents, or a sub-set, of a single field to a    <code>pandas</code> data frame.</li> </ol> <p>Attributes:</p> Name Type Description <code>plan_id</code> <code>tuple[int, ...]</code> <p>The plan ID.</p> <code>batch_id</code> <code>int | None</code> <p>The ID of the evaluation batch that contains the result.</p> <code>metadata</code> <code>dict[str, Any]</code> <p>The metadata.</p>"},{"location":"reference/results/#ropt.results.Results.to_dataframe","title":"<code>to_dataframe(field_name, select=None, unstack=None, names=None)</code>","text":"<p>Export a field to a pandas dataframe.</p> <p>The function exports the values of a single field to a pandas data frame. The field to export is selected by the <code>field_name</code> argument. In general such a field is another object with multiple sub-fields. By default, these are all exported as columns in the pandas data frame, but a sub-set can be selected using the <code>select</code> argument.</p> <p>Any of the sub-fields in the field that is exported may be a multi-dimensional array, which is exported in a stacked manner. Using the axis types found in the metadata, the exporter will construct a multi-index labeled with the corresponding names provided via the <code>names</code> argument. If <code>names</code> is <code>None</code>, numerical indices are used. Such multi-indices can optionally be unstacked into multiple columns by providing the axis types to unstack via the <code>unstack</code> argument.</p> The data frame index <p>As noted above, the index of the resulting data frame may be a multi-index constructed from axis indices or labels. In addition, the <code>plan_id</code> and the <code>batch_id</code> (if not None) fields, are also prepended to the index of the resulting frame.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The field to export.</p> required <code>select</code> <code>Iterable[str] | None</code> <p>Select the sub-fields to export, by default all fields.</p> <code>None</code> <code>unstack</code> <code>Iterable[ResultAxis] | None</code> <p>Select axes to unstack, by default none.</p> <code>None</code> <code>names</code> <code>dict[str, Sequence[str | int] | None] | None</code> <p>A dictionary mapping axis types to names.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the pandas module is not installed.</p> <code>ValueError</code> <p>If the field name is incorrect.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas data frame containing the results.</p> Warning <p>This function is only available if <code>pandas</code> is installed.</p>"},{"location":"reference/results/#ropt.results.Results.transform_back","title":"<code>transform_back(transforms)</code>  <code>abstractmethod</code>","text":"<p>Apply backward transforms to the results.</p> <p>Parameters:</p> Name Type Description Default <code>transforms</code> <code>OptModelTransforms</code> <p>The transforms to apply.</p> required <p>Returns:</p> Type Description <code>Results</code> <p>The transformed results.</p>"},{"location":"reference/results/#ropt.results.ResultField","title":"<code>ropt.results.ResultField</code>  <code>dataclass</code>","text":"<p>Base class for <code>Results</code> fields.</p>"},{"location":"reference/results/#ropt.results.ResultField.get_axes","title":"<code>get_axes(name)</code>  <code>classmethod</code>","text":"<p>Return the axes of a field in the given field class or object.</p> <p>When used with the class or an instance of that class for one of the fields of a <code>Results</code> object, retrieve the axes of the stored <code>numpy</code> array from the metadata and return them.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the sub-field in the instance or class.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if an unknown field name is passed.</p> <p>Returns:</p> Type Description <code>tuple[ResultAxis, ...]</code> <p>A tuple listing the names of the axes.</p>"},{"location":"reference/results/#ropt.results.ResultField.to_dict","title":"<code>to_dict(name, axis=None, names=None)</code>","text":"<p>Convert a field of ResultsField to a dictionary.</p> <p>The keys of the output correspond to the indices of the axis of the field given by <code>axis</code>. The values are a slice of the field value at each index. If <code>names</code> contains the names of the objects stored along the axis, these are used as keys in the output dictionary rather than the numerical indices.</p> <p>If <code>axis</code> is <code>None</code> (the default), a default is chosen using the following logic:</p> <ol> <li>If the field has a <code>ResultAxis.OBJECTIVE</code> axis, it is used.</li> <li>If the field has a <code>ResultAxis.NONLINEAR_CONSTRAINT</code> axis, it is used.</li> <li>Otherwise, use the last axis.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the field to export.</p> required <code>axis</code> <code>ResultAxis | None</code> <p>Axis to use as the keys.</p> <code>None</code> <code>names</code> <code>dict[ResultAxis, tuple[str, ...]] | None</code> <p>A dictionary mapping axis types to names.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str | int, Any]</code> <p>The field converted to a dictionary.</p>"},{"location":"reference/results/#ropt.results.FunctionResults","title":"<code>ropt.results.FunctionResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Results</code></p> <p>The <code>FunctionResults</code> class stores function related results.</p> <p>This class contains  the following additional information:</p> <ol> <li>The results of the function evaluations.</li> <li>The parameters of the realizations, such as weights for objectives and    constraints, and realization failures.</li> <li>The calculated objective and constraint function values.</li> </ol> <p>Attributes:</p> Name Type Description <code>evaluations</code> <code>FunctionEvaluations</code> <p>Results of the function evaluations.</p> <code>realizations</code> <code>Realizations</code> <p>The calculated parameters of the realizations.</p> <code>functions</code> <code>Functions | None</code> <p>The calculated functions.</p>"},{"location":"reference/results/#ropt.results.FunctionResults.transform_back","title":"<code>transform_back(transforms)</code>","text":"<p>Apply backward transforms to the results.</p> <p>Parameters:</p> Name Type Description Default <code>transforms</code> <code>OptModelTransforms</code> <p>The transforms to apply.</p> required <p>Returns:</p> Type Description <code>FunctionResults</code> <p>The transformed results.</p>"},{"location":"reference/results/#ropt.results.FunctionEvaluations","title":"<code>ropt.results.FunctionEvaluations</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResultField</code></p> <p>This class contains the results of evaluations for function calculation.</p> <p>This class stores the variables with the calculated objective and constraint functions. It contains the following information:</p> <ol> <li>The vector of variables at which the functions are evaluated.</li> <li>The calculated objectives and constraints for each realization: A    two-dimensional array, with the objective or constraint values arranged    along the second axis. The first axis index indicates the realization    number.</li> <li>Optional evaluation IDs that may have been passed from the evaluator,    identifying each calculated realization.</li> </ol> <p>Attributes:</p> Name Type Description <code>variables</code> <code>NDArray[float64]</code> <p>The unperturbed variable vector.</p> <code>objectives</code> <code>NDArray[float64]</code> <p>The objective functions for each realization.</p> <code>constraints</code> <code>NDArray[float64] | None</code> <p>The constraint functions for each realization.</p> <code>evaluation_ids</code> <code>NDArray[intc] | None</code> <p>Optional id of each evaluated realization.</p>"},{"location":"reference/results/#ropt.results.Realizations","title":"<code>ropt.results.Realizations</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResultField</code></p> <p>This class stores information on the realizations.</p> <p>The <code>failed_realizations</code> field is a boolean array that indicates for each realization whether the evaluation was successful or not.</p> <p>Depending on the type of objective or constraint calculation, the weights used for the realizations may change during optimization. This class stores for each objective and constraint a vector of weight values.</p> <p>All fields are two-dimensional matrices, where the first axis index denotes the function or constraint. The second axis index denotes the realization.</p> <p>Attributes:</p> Name Type Description <code>failed_realizations</code> <code>NDArray[bool_]</code> <p>Failed realizations.</p> <code>objective_weights</code> <code>NDArray[float64] | None</code> <p>Realization weights for the objectives.</p> <code>constraint_weights</code> <code>NDArray[float64] | None</code> <p>Realization weights for the constraints.</p>"},{"location":"reference/results/#ropt.results.Functions","title":"<code>ropt.results.Functions</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResultField</code></p> <p>Store the calculated objective and constraint functions.</p> <p>The objective and constraint functions used by the optimizer are calculated from their values evaluated for all realizations, for instance by averaging. There may be multiple objectives and constraints. Multiple objectives are handled by the optimizer using a weighted sum, stored in the <code>weighted_objective</code> field. Multiple constraints are directly handled by the optimizer.</p> <p>Attributes:</p> Name Type Description <code>weighted_objective</code> <code>NDArray[float64]</code> <p>The weighted sum of the objectives.</p> <code>objectives</code> <code>NDArray[float64]</code> <p>The value of each objective.</p> <code>constraints</code> <code>NDArray[float64] | None</code> <p>The value of each constraint.</p>"},{"location":"reference/results/#ropt.results.GradientResults","title":"<code>ropt.results.GradientResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Results</code></p> <p>The <code>GradientResults</code> class stores gradient related results.</p> <p>This contains  the following additional information:</p> <ol> <li>The results of the function evaluations for perturbed variables.</li> <li>The parameters of the realizations, such as weights for objectives and    constraints, and realization failures.</li> <li>The gradients of the calculated objectives and constraints.</li> </ol> <p>Attributes:</p> Name Type Description <code>evaluations</code> <code>GradientEvaluations</code> <p>Results of the function evaluations.</p> <code>realizations</code> <code>Realizations</code> <p>The calculated parameters of the realizations.</p> <code>gradients</code> <code>Gradients | None</code> <p>The calculated gradients.</p>"},{"location":"reference/results/#ropt.results.GradientResults.transform_back","title":"<code>transform_back(transforms)</code>","text":"<p>Apply backward transforms to the results.</p> <p>Parameters:</p> Name Type Description Default <code>transforms</code> <code>OptModelTransforms</code> <p>The transforms to apply.</p> required <p>Returns:</p> Type Description <code>GradientResults</code> <p>The transformed results.</p>"},{"location":"reference/results/#ropt.results.GradientEvaluations","title":"<code>ropt.results.GradientEvaluations</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResultField</code></p> <p>This class contains the results of evaluations for gradient calculation.</p> <p>This class stores the variables with the calculated objective and constraints gradients. It contains the following information:</p> <ol> <li>The vector of variables at which the functions are evaluated.</li> <li>A three-dimensional array of perturbed variables, with variable values    arranged along the third axis. The second axis index indicates the    perturbation number, whereas the first axis index represents the    realization number.</li> <li>The objectives and constraints for each realization and perturbed    variable vector:  A three-dimensional array, with the objective or    constraint values arranged along the third axis. The second axis index    indicates the perturbation number, whereas the first axis index    represents the realization number.</li> <li>Optional evaluation IDs that may have been passed from the evaluator,    identifying each calculated realization and perturbation.</li> </ol> <p>Attributes:</p> Name Type Description <code>variables</code> <code>NDArray[float64]</code> <p>The unperturbed variable vector.</p> <code>perturbed_variables</code> <code>NDArray[float64]</code> <p>The variables for each realization and perturbation.</p> <code>perturbed_objectives</code> <code>NDArray[float64]</code> <p>The objective functions for each realization and                       perturbation.</p> <code>perturbed_constraints</code> <code>NDArray[float64] | None</code> <p>The constraint functions for each realization and                       perturbation.</p> <code>perturbed_evaluation_ids</code> <code>NDArray[intc] | None</code> <p>Optional id of each evaluated realization.</p>"},{"location":"reference/results/#ropt.results.Gradients","title":"<code>ropt.results.Gradients</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResultField</code></p> <p>This class stores the calculated objective and constraint gradients.</p> <p>The objective and constraint gradients used by the optimizer are calculated from their values evaluated for all realizations, for instance by averaging. There may be multiple objectives and constraints. Multiple objectives are handled by the optimizer using a weighted sum of the individual gradients, stored in the <code>weighted_objective</code> field. Multiple constraints are directly handled by the optimizer.</p> <p>Attributes:</p> Name Type Description <code>weighted_objective</code> <code>NDArray[float64]</code> <p>The weighted sum of the objective gradients.</p> <code>objectives</code> <code>NDArray[float64]</code> <p>The value of each objective gradient.</p> <code>constraints</code> <code>NDArray[float64] | None</code> <p>The value of each constraint gradient.</p>"},{"location":"reference/sampler_plugins/","title":"Sampler Plugins","text":""},{"location":"reference/sampler_plugins/#ropt.plugins.sampler","title":"<code>ropt.plugins.sampler</code>","text":"<p>Plugin functionality for adding sampler plugins.</p> <p>Sampler plugins are managed by a <code>PluginManager</code> object, which returns classes or factory functions to create objects that implement one or more sampling methods to produce perturbations. These objects must adhere to the <code>Sampler</code> abstract base class.</p> <p>Samplers can be added via the plugin manager, by default the <code>SciPySampler</code> plugin is installed which provides a number of methods from the <code>scipy.stats</code> package.</p>"},{"location":"reference/sampler_plugins/#ropt.plugins.sampler.base","title":"<code>ropt.plugins.sampler.base</code>","text":"<p>This module defines the abstract base class for samplers.</p> <p>Samplers can be added via the plugin mechanism to implement additional ways to generate perturbed variables. Any object that follows the <code>Sampler</code> abstract base class may be installed as a plugin.</p>"},{"location":"reference/sampler_plugins/#ropt.plugins.sampler.base.Sampler","title":"<code>Sampler</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for sampler classes.</p> <p><code>ropt</code> employs plugins to implement samplers that are called during an optimization plan to generate perturbed variable vectors. Samplers should derive from the <code>Sampler</code> base class, which specifies the requirements for the class constructor (<code>__init__</code>) and also includes a <code>generate_samples</code> method used to generate samples used to create perturbed values.</p>"},{"location":"reference/sampler_plugins/#ropt.plugins.sampler.base.Sampler.__init__","title":"<code>__init__(enopt_config, sampler_index, mask, rng)</code>  <code>abstractmethod</code>","text":"<p>Initialize the sampler object.</p> <p>The <code>samplers</code> field in the <code>enopt_config</code> configuration used by the optimization is a tuple of sampler configurations (see <code>SamplerConfig</code>). The <code>sampler_index</code> field is used to identify the configuration to use to initialize this sampler.</p> <p>The sampler may be used for a subset of the variables. The boolean <code>mask</code> array indicates the variables that are handled by this sampler.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The configuration of the optimizer.</p> required <code>sampler_index</code> <code>int</code> <p>The index of the sampler to use.</p> required <code>mask</code> <code>NDArray[bool_] | None</code> <p>The mask of the variables to sample.</p> required <code>rng</code> <code>Generator</code> <p>A random generator object for use by stochastic samplers.</p> required"},{"location":"reference/sampler_plugins/#ropt.plugins.sampler.base.Sampler.generate_samples","title":"<code>generate_samples()</code>  <code>abstractmethod</code>","text":"<p>Return an array containing sampled values.</p> <p>The result should be a three-dimensional array of perturbation values. The variable values are stored along the last axis, for each realization and perturbation. The first axis indexes the realization, and the second axis indexes the perturbation.</p> <p>If the <code>shared</code> flag is set in the <code>SamplerConfig</code> configuration, the first dimension should have a length equal to one, since all realizations will use the same set of perturbations.</p> <p>The sampler may handle only a subset of the variables, as specified by the <code>variable_indices</code> argument of the constructor. In this case, only the corresponding values along the variables axis (the last axis) should be set, while other values should be zero.</p> Sample scaling <p>Samples will be multiplied by the values given by the <code>perturbation_magnitudes</code> field in the <code>gradients</code> section of the optimizer configuration. It makes therefore sense to generate samples that have an order of magnitude around one. For instance, by generating them on a <code>[-1, 1]</code> range, or with a unit standard deviation.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The sampled values.</p>"},{"location":"reference/sampler_plugins/#ropt.plugins.sampler.base.SamplerPlugin","title":"<code>SamplerPlugin</code>","text":"<p>               Bases: <code>Plugin</code></p> <p>Abtract base class for sampler plugins.</p>"},{"location":"reference/sampler_plugins/#ropt.plugins.sampler.base.SamplerPlugin.create","title":"<code>create(enopt_config, sampler_index, mask, rng)</code>  <code>abstractmethod</code>","text":"<p>Create a sampler.</p> <p>Parameters:</p> Name Type Description Default <code>enopt_config</code> <code>EnOptConfig</code> <p>The configuration of the optimizer.</p> required <code>sampler_index</code> <code>int</code> <p>The index of the sampler to use.</p> required <code>mask</code> <code>NDArray[bool_] | None</code> <p>The indices of the variables to sample.</p> required <code>rng</code> <code>Generator</code> <p>A random generator object for use by stochastic samplers.</p> required"},{"location":"reference/scipy_optimizer_plugin/","title":"SciPy Optimizer Plugin","text":""},{"location":"reference/scipy_optimizer_plugin/#ropt.plugins.optimizer.scipy.SciPyOptimizer","title":"<code>ropt.plugins.optimizer.scipy.SciPyOptimizer</code>","text":"<p>               Bases: <code>Optimizer</code></p> <p>Plugin class for optimization via SciPy.</p> <p>This class implements several optimizers provided by SciPy in the <code>scipy.optimize</code> package:</p> <ul> <li>Nelder-Mead</li> <li>Powell</li> <li>CG</li> <li>BFGS</li> <li>Newton-CG</li> <li>L-BFGS-B</li> <li>TNC</li> <li>COBYLA</li> <li>SLSQP</li> <li>differential_evolution</li> </ul> <p>The optimizer to use is selected by setting the <code>method</code> field in the <code>optimizer</code> field of <code>EnOptConfig</code> to the name of the algorithm. Most of these methods support the general options set in the <code>EnOptConfig</code> object. However, specific options that are normally passed as arguments in the SciPy functions can be provided via the <code>options</code> dictionary in the configuration object. Consult the <code>scipy.optimize</code> manual for details on these options.</p> <p>Not all constraints are supported by all optimizers:</p> <ul> <li>Bound constraints: Nelder-Mead, L-BFGS-B, SLSQP, TNC,   differential_evolution</li> <li>Linear constraints: SLSQP, differential_evolution</li> <li>Nonlinear constraints: COBYLA (only inequality), SLSQP,   differential_evolution</li> </ul> Info <ul> <li>The Nelder-Mead algorithm only supports bound constraints if SciPy   version &gt;= 1.7.</li> <li>Some SciPy algorithms that require a Hessian or a Hessian-vector   product are not supported. These include dogleg, trust-ncg,   trust-exact, and trust-krylov.</li> </ul>"},{"location":"reference/scipy_sampler_plugin/","title":"SciPy Sampler Plugin","text":""},{"location":"reference/scipy_sampler_plugin/#ropt.plugins.sampler.scipy.SciPySampler","title":"<code>ropt.plugins.sampler.scipy.SciPySampler</code>","text":"<p>               Bases: <code>Sampler</code></p> <p>Plugin class for producing sampling values via SciPy.</p> <p>This plugin implements the following sampling methods using the corresponding methods from the SciPy stats module:</p> <ul> <li> <p>Sampling from probability   distributions:</p> <code>uniform</code> Uniform distribution with a default range of [-1, 1]. <code>norm</code> Normal distribution with mean zero and standard deviation 1. <code>truncnorm</code> Truncated normal distribution with mean zero and standard   deviation 1 truncated a the range [-1, 1]. </li> <li> <p>Sampling using methods from the Quasi-Monte Carlo   submodule:</p> <code>sobol</code> Using Sobol sequences, scaled to -1 and 1. <code>halton</code> Using Halton sequences, scaled to -1 and 1. <code>lhs</code> Using Latin Hypercube sampling, scaled to -1 and 1. </li> </ul> <p>Specific options that are normally passed as arguments in the SciPy functions can be provided via the options dictionary in the configuration object. Consult the <code>scipy.stats</code> manual for details on these options.</p>"},{"location":"reference/utilities/","title":"Utilities","text":""},{"location":"reference/utilities/#ropt.config.utils","title":"<code>ropt.config.utils</code>","text":"<p>Utilities for checking configuration values.</p> <p>These utilities are intended to be used in the model validation code of Pydantic models.</p>"},{"location":"reference/utilities/#ropt.config.utils.ImmutableBaseModel","title":"<code>ImmutableBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for immutable classes.</p> <p>This model serves as an alternative to frozen Pydantic classes. It is particularly useful when post-initialization validators are required, as these validators may not function properly with frozen Pydantic classes.</p>"},{"location":"reference/utilities/#ropt.config.utils.ImmutableBaseModel.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Attribute setter method.</p> <p>This method sets an attribute if the object is not immutable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>value</code> <code>Any</code> <p>The value to assign to the attribute.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>Raised if the object is immutable and cannot be modified.</p>"},{"location":"reference/utilities/#ropt.config.utils.normalize","title":"<code>normalize(array)</code>","text":"<p>Normalize a vector.</p> <p>Normalize the sum of the values to one.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArray[float64]</code> <p>The input array.</p> required <p>Returns:</p> Name Type Description <code>ValueError</code> <code>NDArray[float64]</code> <p>The normalized array</p>"},{"location":"reference/utilities/#ropt.config.utils.immutable_array","title":"<code>immutable_array(array_like, **kwargs)</code>","text":"<p>Make an immutable array.</p> <p>Converts the input to an array and makes it immutable.`</p> <p>Parameters:</p> Name Type Description Default <code>array_like</code> <code>ArrayLike</code> <p>The input.</p> required <code>kwargs</code> <code> </code> <p>Additional keyword arguments for array conversion.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[Any]</code> <p>The immutable array.</p>"},{"location":"reference/utilities/#ropt.config.utils.broadcast_arrays","title":"<code>broadcast_arrays(*args)</code>","text":"<p>Broadcast a set of arrays to a common dimensionality and makes them immutable.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The input arrays.</p> <code>()</code> <p>Returns:</p> Type Description <code>tuple[NDArray[Any], ...]</code> <p>The broadcasted immutable arrays.</p>"},{"location":"reference/utilities/#ropt.config.utils.broadcast_1d_array","title":"<code>broadcast_1d_array(array, name, size)</code>","text":"<p>Broadcast the input array to an 1D array of given size.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>NDArray[Any]</code> <p>The input array.</p> required <code>name</code> <code>str</code> <p>The name of the array, used in an error message.</p> required <code>size</code> <code>int</code> <p>The size of the result.</p> required <p>Returns:</p> Type Description <code>NDArray[Any]</code> <p>An 1D array of the requested size.</p>"},{"location":"reference/utilities/#ropt.config.utils.check_enum_values","title":"<code>check_enum_values(value, enum_type)</code>","text":"<p>Check if an enum value is valid.</p> <p>Given an array of byte integers, check of the values are within the range of values of the given enum.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NDArray[ubyte]</code> <p>The enum values.</p> required <code>enum_type</code> <code>Type[IntEnum]</code> <p>The type to check.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array contains an invalid value.</p>"},{"location":"reference/utilities/#ropt.config.validated_types","title":"<code>ropt.config.validated_types</code>","text":"<p>Annotated types for use with Pydantic models.</p> <p>These types can be used to convert input values to a desired type and guarantee certain properties. They include types that convert inputs to immutable NumPy arrays of specified dimension and type:</p> <ul> <li><code>Array1D</code>: For converting sequences to   immutable one-dimensional floating-point arrays.</li> <li><code>Array2D</code>: For converting sequences to   immutable two-dimensional floating-point arrays.</li> <li><code>ArrayEnum</code>: For converting   sequences to values of numerical enumerations of any dimension.</li> <li><code>Array1DInt</code>: For converting   sequences to immutable one-dimensional integer arrays.</li> <li><code>Array1DBool</code>: For converting   sequences to immutable one-dimensional boolean arrays.</li> </ul> <p>Additionally, the following convenience types create sets or tuples, ensuring that single values are embedded in a set or tuple, respectively:</p> <ul> <li><code>ItemOrSet[T]</code>: Create a set of type <code>T</code>.</li> <li><code>ItemOrTuple[T]</code>: Create a tuple of type <code>T</code>.</li> </ul>"},{"location":"reference/utilities/#ropt.config.validated_types.Array1D","title":"<code>Array1D = Annotated[NDArray[np.float64], BeforeValidator(_convert_1d_array)]</code>  <code>module-attribute</code>","text":"<p>Convert to an immutable 1D numpy array of floating point values.</p>"},{"location":"reference/utilities/#ropt.config.validated_types.Array2D","title":"<code>Array2D = Annotated[NDArray[np.float64], BeforeValidator(_convert_2d_array)]</code>  <code>module-attribute</code>","text":"<p>Convert to an immutable 2D numpy array of floating point values.</p>"},{"location":"reference/utilities/#ropt.config.validated_types.ArrayEnum","title":"<code>ArrayEnum = Annotated[NDArray[np.ubyte], BeforeValidator(_convert_enum_array)]</code>  <code>module-attribute</code>","text":"<p>Convert to an immutable numpy array of numerical enumeration values.</p>"},{"location":"reference/utilities/#ropt.config.validated_types.Array1DInt","title":"<code>Array1DInt = Annotated[NDArray[np.intc], BeforeValidator(_convert_1d_array_intc)]</code>  <code>module-attribute</code>","text":"<p>Convert to an immutable 1D numpy array of integer values.</p>"},{"location":"reference/utilities/#ropt.config.validated_types.Array1DBool","title":"<code>Array1DBool = Annotated[NDArray[np.bool_], BeforeValidator(_convert_1d_array_bool)]</code>  <code>module-attribute</code>","text":"<p>Convert to an immutable 1D numpy array of boolean values.</p>"},{"location":"reference/utilities/#ropt.config.validated_types.ItemOrSet","title":"<code>ItemOrSet = Annotated[set[T], BeforeValidator(_convert_set)]</code>  <code>module-attribute</code>","text":"<p>Convert to single value to a set containing that value, passes sets unchanged.</p>"},{"location":"reference/utilities/#ropt.config.validated_types.ItemOrTuple","title":"<code>ItemOrTuple = Annotated[tuple[T, ...], BeforeValidator(_convert_tuple)]</code>  <code>module-attribute</code>","text":"<p>Convert to single value to a tuple containing that value, passes sets unchanged.</p>"},{"location":"usage/robust_optimization/","title":"Introduction: Ensemble-based robust optimization","text":"<p>Constraint optimization is the process of optimizing an objective function \\(f(\\mathbf{x})\\) with respect to a vector of variables \\(\\mathbf{x}\\) in the presence of one or more inequality constraints \\(g_j(\\mathbf{x})\\) and/or equality constraints \\(h_k(\\mathbf{x})\\).</p> \\[ \\begin{align} \\textrm{minimize} \\quad &amp; f(\\mathbf{x}) \\\\ \\textrm{subject to} \\quad &amp; g_j(\\mathbf{x}) \\le 0, \\quad j=1, \\ldots, J \\\\ &amp; h_k(\\mathbf{x}) = 0, \\quad k=1, \\ldots, K \\\\ &amp; \\mathbf{x}^L \\le \\mathbf{x} \\le \\mathbf{x}^U \\end{align} \\] <p>In this context, the function \\(f(\\mathbf{x})\\) is assumed to have a deterministic nature, meaning it is well-defined for given parameters. However, in realistic scenarios, \\(f(\\mathbf{x})\\) may be part of a larger set of functions, especially if it depends on uncertain parameters drawn from some, possibly unknown, probability distribution.</p> <p>Ensemble-based robust optimization aims to optimize an ensemble of functions \\(f_i(\\mathbf{x})\\) with respect to \\(\\mathbf{x}\\). The set of realizations \\(f_i\\) captures the uncertainty that may exist in the model, which can be, for instance, constructed by varying some parameters according to a given probability distribution. When given a set of realizations, ensemble-based optimization proceeds by combining the functions \\(f_i(\\mathbf{x})\\) into a single objective function. For example, using a weighted sum, the problem becomes (ignoring constraints):</p> \\[ \\textrm{minimize} \\quad \\sum_i w_i f_i(\\mathbf{x}), \\] <p>where \\(w_i\\) represents the weights assigned to the different realizations. In more complex settings, the realizations may also be combined in different ways, and the set of realizations may be modified during optimization. For instance, risk-aware objectives may be constructed by minimizing the standard deviation of the functions or by selecting some of the worst-performing realizations at each iteration.</p> <p>In practice, the optimization task often becomes complex due to additional factors. The evaluation of functions might be computationally expensive, and calculating their gradients analytically can be challenging or even impossible. For example, the functions may involve lengthy simulations of a physical process with numerous variables, utilizing numerical calculations that preclude straightforward analytical differentiation.</p> <p><code>ropt</code> leverages standard optimization algorithms, such as those available in the SciPy package. These methods typically follow an iterative approach, necessitating repeated assessments of the objective function and, in many cases, its gradient. Currently, it is assumed that the functions are not easily differentiated analytically. One of the core functions of <code>ropt</code> is to calculate gradients efficiently using stochastic methods.</p> <p><code>ropt</code> is responsible for configuring and executing the optimization algorithm, building the overall function and gradient values from individual realizations, and monitoring both intermediate and final optimization results. It also offers the flexibility to delegate the actual calculations of functions to external code, for example, utilizing distributed resources like HPC clusters. <code>ropt</code> optionally provides its own code for this purpose.</p> <p>While many optimization scenarios involve a single run of a particular method, there are cases where it proves beneficial to conduct multiple runs using the same or different algorithms. For example, when dealing with a mix of continuous and discrete variables, it might be advantageous to employ different methods for each variable type. <code>ropt</code> facilitates this by offering a mechanism to run a workflow containing multiple optimizers, potentially of different types, in an alternating or nested fashion.</p>"},{"location":"usage/running/","title":"Running a basic optimization script","text":"<p>To demonstrate basic optimization with <code>ropt</code>, consider the Rosenbrock function, a standard test problem:</p> \\[ f(x,y) = (a - x)^2 + b (y - x^2)^2, \\] <p>which has a global minimum of \\(f(x, y) = 0\\) at \\((x, y) = (a, a^2)\\) .</p> <p>Here's an example optimizing the Rosenbrock function for \\(a = 1\\) and \\(b = 100\\):</p> <pre><code>import numpy as np\nfrom numpy.typing import NDArray\n\nfrom ropt.evaluator import EvaluatorContext, EvaluatorResult\nfrom ropt.plan import BasicOptimizer\n\n\ndef rosenbrock(\n    variables: NDArray[np.float64],                                   # (1)!\n    context: EvaluatorContext                                         # (2)!\n) -&gt; EvaluatorResult:\n    objectives = np.zeros((variables.shape[0], 1), dtype=np.float64)\n    for idx in range(variables.shape[0]):\n        x, y = variables[idx, :]\n        objectives[idx, 0] = (1.0 - x) ** 2 + 100 * (y - x * x) ** 2\n    return EvaluatorResult(objectives=objectives)                     # (3)!\n\nCONFIG = {                                                            # (4)!\n    \"variables\": {\"initial_values\": [0.5, 2.0]},\n    \"gradient\": {\"perturbation_magnitudes\": 1e-5}                     # (5)!\n}\n\noptimum = BasicOptimizer(CONFIG, rosenbrock).run().results            # (6)!\n\nprint(optimum.evaluations.variables, optimum.functions.weighted_objective)\n</code></pre> <ol> <li>The variables to optimize (\\(x, y\\)) are passes as a single <code>numpy</code> array. The    function may receive multiple variable vectors to evaluate, hence the input    is a matrix where the variable vectors are the rows of the matrix.</li> <li>Additional information is passes via an    <code>EvaluatorContext</code> object. It is not    needed in this case.</li> <li>Results are returned via an    <code>EvaluatorResult</code> object. The objectives    result is a matrix since multiple input vectors and multiple objectives may    be evaluated.</li> <li>Create an optimizer configuration with default values except for initial    values and perturbation magnitudes.</li> <li>Set perturbation magnitudes to a small value for accurate gradient    estimation.</li> <li>Make an <code>BasicOptimizer</code> plan, run it, and    retrieve the results.</li> </ol> <p>Running this will print the estimated optimal variables and the corresponding function value:</p> <pre><code>[1.00117794 1.0023715 ] 1.4078103983185034e-06\n</code></pre> <p>This example uses the BasicOptimizer class which provides a simplified interface for running optimizations. More complex optimization workflows can be implemented using the plan functionality.</p>"}]}